<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataMerge - Professional PDF Data Merging Tool | CSV to PDF Generator</title>
    <meta name="description" content="DataMerge is the ultimate PDF data merging tool. Convert CSV data to professional PDFs with drag-and-drop interface. Perfect for certificates, invoices, and bulk document generation.">
    <meta name="keywords" content="PDF merge, CSV to PDF, data merge, bulk PDF generation, document automation, PDF generator, CSV converter, merge data, PDF template, certificate generator, invoice generator, mail merge, document processing">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>📄</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" id="jszip-cdn"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
            padding: 20px;
        }

        /* Landing Page Styles */
        .landing-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 10000;
            overflow-y: auto;
            display: none;
        }

        .landing-page.show {
            display: block;
        }

        .landing-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .landing-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10001;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        }

        .landing-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
        }

        .landing-logo {
            font-size: 1.8rem;
            font-weight: 700;
            color: #667eea;
            text-decoration: none;
        }

        .landing-nav-links {
            display: flex;
            list-style: none;
            gap: 2rem;
        }

        .landing-nav-links a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .landing-nav-links a:hover {
            color: #667eea;
        }

        .landing-cta-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 50px;
            text-decoration: none;
            font-weight: 600;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            border: none;
        }

        .landing-cta-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .landing-hero {
            padding: 120px 0 80px;
            text-align: center;
            color: white;
        }

        .landing-hero h1 {
            font-size: 3.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .landing-hero .subtitle {
            font-size: 1.3rem;
            margin-bottom: 2rem;
            opacity: 0.9;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .landing-hero-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 3rem;
        }

        .landing-btn-primary {
            background: white;
            color: #667eea;
            padding: 1rem 2rem;
            border-radius: 50px;
            text-decoration: none;
            font-weight: 600;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            border: none;
        }

        .landing-btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
        }

        .landing-btn-secondary {
            background: transparent;
            color: white;
            border: 2px solid white;
            padding: 1rem 2rem;
            border-radius: 50px;
            text-decoration: none;
            font-weight: 600;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .landing-btn-secondary:hover {
            background: white;
            color: #667eea;
        }

        .landing-features {
            background: white;
            padding: 80px 0;
        }

        .landing-section-title {
            text-align: center;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 3rem;
            color: #333;
        }

        .landing-features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .landing-feature-card {
            background: #f8f9fa;
            padding: 2rem;
            border-radius: 15px;
            text-align: center;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .landing-feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }

        .landing-feature-icon {
            font-size: 3rem;
            color: #667eea;
            margin-bottom: 1rem;
        }

        .landing-feature-card h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #333;
        }

        .landing-feature-card p {
            color: #666;
            line-height: 1.6;
        }

        .landing-how-it-works {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 80px 0;
        }

        .landing-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }

        .landing-step {
            text-align: center;
            position: relative;
        }

        .landing-step-number {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0 auto 1rem;
        }

        .landing-step h3 {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #333;
        }

        .landing-step p {
            color: #666;
        }

        .landing-benefits {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 80px 0;
        }

        .landing-benefits-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }

        .landing-benefit-item {
            text-align: center;
            padding: 1.5rem;
        }

        .landing-benefit-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            opacity: 0.9;
        }

        .landing-benefit-item h3 {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .landing-benefit-item p {
            opacity: 0.9;
            line-height: 1.6;
        }

        .landing-footer {
            background: #333;
            color: white;
            padding: 40px 0 20px;
            text-align: center;
        }

        .landing-footer-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .landing-footer-section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #667eea;
        }

        .landing-footer-section ul {
            list-style: none;
        }

        .landing-footer-section ul li {
            margin-bottom: 0.5rem;
        }

        .landing-footer-section ul li a {
            color: #ccc;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .landing-footer-section ul li a:hover {
            color: #667eea;
        }

        .landing-footer-bottom {
            border-top: 1px solid #555;
            padding-top: 1rem;
            color: #999;
        }

        /* Privacy Policy Modal */
        .privacy-modal {
            display: none;
            position: fixed;
            z-index: 10002;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .privacy-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .privacy-modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 0;
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .privacy-modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .privacy-modal-header h2 {
            margin: 0;
            font-size: 1.8rem;
            font-weight: 600;
        }

        .privacy-close {
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }

        .privacy-close:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .privacy-modal-body {
            padding: 30px;
            line-height: 1.6;
        }

        .privacy-modal-body h3 {
            color: #667eea;
            font-size: 1.3rem;
            font-weight: 600;
            margin: 25px 0 10px 0;
        }

        .privacy-modal-body h3:first-child {
            margin-top: 0;
        }

        .privacy-modal-body p {
            color: #555;
            margin-bottom: 15px;
        }

        .privacy-modal-body strong {
            color: #333;
        }

        /* Scrollbar styling for modal */
        .privacy-modal-content::-webkit-scrollbar {
            width: 8px;
        }

        .privacy-modal-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .privacy-modal-content::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .privacy-modal-content::-webkit-scrollbar-thumb:hover {
            background: #5a6fd8;
        }

        @media (max-width: 768px) {
            .landing-nav-links {
                display: none;
            }
            
            .landing-hero h1 {
                font-size: 2.5rem;
            }
            
            .landing-hero .subtitle {
                font-size: 1.1rem;
            }
            
            .landing-hero-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .landing-btn-primary, .landing-btn-secondary {
                width: 100%;
                max-width: 300px;
            }
            
            .landing-features-grid {
                grid-template-columns: 1fr;
            }
            
            .landing-steps {
                grid-template-columns: 1fr;
            }
            
            .privacy-modal-content {
                width: 95%;
                margin: 2% auto;
                max-height: 90vh;
            }
            
            .privacy-modal-header {
                padding: 15px 20px;
            }
            
            .privacy-modal-header h2 {
                font-size: 1.5rem;
            }
            
            .privacy-modal-body {
                padding: 20px;
            }
            
            .privacy-modal-body h3 {
                font-size: 1.2rem;
            }
        }

        .main-container {
            display: flex;
            height: calc(100vh - 40px);
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .sidebar.collapsed {
            width: 50px;
        }

        .sidebar-header {
            background: #007bff;
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h1 {
            font-size: 16px;
            white-space: nowrap;
            overflow: hidden;
        }

        .toggle-sidebar {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            padding: 5px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .sidebar.collapsed .sidebar-content {
            display: none;
        }

        .section {
            margin-bottom: 20px;
        }

        .section-header {
            font-size: 11px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Enhanced Box Management Styles */
        .box-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .box-type-buttons {
            display: flex;
            gap: 4px;
        }

        .box-type-buttons .btn {
            flex: 1;
            margin-bottom: 0;
            font-size: 10px;
            padding: 6px 4px;
        }

        .box-editor {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
            display: none;
        }

        .box-editor.active {
            display: block;
        }

        .box-editor h4 {
            font-size: 12px;
            margin-bottom: 8px;
            color: #333;
        }

        .form-group {
            margin-bottom: 8px;
        }

        .form-group label {
            display: block;
            font-size: 10px;
            font-weight: 500;
            color: #666;
            margin-bottom: 2px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
        }

        .form-group input[type="color"] {
            height: 24px;
            padding: 2px;
        }

        .form-row {
            display: flex;
            gap: 6px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .checkbox-group {
            display: flex;
            gap: 8px;
            margin-top: 4px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .checkbox-item label {
            font-size: 9px;
            margin: 0;
            color: #666;
        }

        /* Image Loading Progress Bar */
        .image-loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .image-loading-overlay.active {
            display: flex;
        }

        .image-loading-content {
            background: white;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .image-loading-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
        }

        .image-loading-subtitle {
            font-size: 14px;
            color: #666;
            margin-bottom: 25px;
        }

        .image-progress-container {
            background: #f0f0f0;
            border-radius: 20px;
            height: 8px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .image-progress-bar {
            background: linear-gradient(90deg, #007bff, #0056b3);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 20px;
        }

        .image-progress-text {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }

        .image-loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Font Upload Styles */
        .font-upload-area {
            border: 2px dashed #ccc;
            border-radius: 4px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .font-upload-area:hover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .font-upload-area.dragover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .font-upload-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .font-upload-content span {
            font-size: 20px;
        }

        .font-upload-content p {
            font-size: 10px;
            margin: 0;
            color: #666;
        }

        .google-font-input {
            display: flex;
            gap: 4px;
        }

        .google-font-input input {
            flex: 1;
            font-size: 10px;
        }

        .google-font-input button {
            font-size: 10px;
            padding: 4px 8px;
            white-space: nowrap;
        }

        .font-status {
            font-size: 9px;
            margin-top: 4px;
            min-height: 12px;
        }

        .font-status.success {
            color: #28a745;
        }

        .font-status.error {
            color: #dc3545;
        }

        .font-status.warning {
            color: #ffc107;
        }
        
        /* Collapsible Drawers */
        .drawer {
            border-bottom: 1px solid #e0e0e0;
            background: white;
            margin-bottom: 10px;
        }

        .drawer-header {
            padding: 12px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #333;
            transition: background-color 0.2s;
            font-size: 12px;
        }

        .drawer-header:hover {
            background: #e9ecef;
        }

        .drawer-header.active {
            background: #007bff;
            color: white;
        }

        .drawer-icon {
            transition: transform 0.3s;
            font-size: 14px;
        }

        .drawer-header.active .drawer-icon {
            transform: rotate(180deg);
        }

        .drawer-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: white;
        }

        /* Make file uploads drawer open by default */
        #uploadContent {
            max-height: 600px;
            overflow-y: auto;
        }

        .drawer-content.open {
            max-height: 600px;
            overflow-y: auto;
        }

        .drawer-content-inner {
            padding: 15px;
        }


        


        .style-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .style-checkboxes .checkbox-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
        }

        .style-checkboxes .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .style-checkboxes .checkbox-item span {
            color: #666;
        }

        /* Record Navigation Styles */
        .record-navigation {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
        }

        .nav-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .nav-controls button {
            padding: 4px 8px;
            font-size: 10px;
            min-width: 30px;
        }

        .nav-controls span {
            font-size: 10px;
            color: #666;
            flex: 1;
            text-align: center;
        }

        .box-actions {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }

        .box-actions .btn {
            flex: 1;
            margin-bottom: 0;
            font-size: 9px;
            padding: 4px 6px;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        /* CSV Preview Enhancement */
        .csv-preview {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            max-height: 120px;
            overflow-y: auto;
        }

        .csv-table {
            width: 100%;
            font-size: 9px;
            border-collapse: collapse;
        }

        .csv-table th,
        .csv-table td {
            padding: 2px 4px;
            border: 1px solid #e9ecef;
            text-align: left;
        }

        .csv-table th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .csv-table td {
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-input {
            display: block;
            width: 100%;
            padding: 8px;
            border: 2px dashed #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            text-align: center;
            transition: border-color 0.3s;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .file-input:hover {
            border-color: #007bff;
        }

        .file-input input[type="file"] {
            display: none;
        }

        .btn {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-bottom: 6px;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Download buttons styling - more compact */
        .download-buttons .btn {
            width: auto;
            padding: 6px 12px;
            font-size: 11px;
            white-space: nowrap;
            min-width: 120px;
        }

        .status-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #666;
        }



        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #f8f9fa;
            position: relative;
        }

        .content-header {
            background: white;
            border-bottom: 1px solid #e9ecef;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-header h3 {
            font-size: 14px;
            color: #333;
        }

        .editor-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .editor-btn {
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: background-color 0.3s;
        }

        .editor-btn-primary {
            background: #007bff;
            color: white;
        }

        .editor-btn-primary:hover {
            background: #0056b3;
        }

        .editor-btn-secondary {
            background: #6c757d;
            color: white;
        }

        .editor-btn-secondary:hover {
            background: #545b62;
        }

        .editor-btn-success {
            background: #28a745;
            color: white;
        }

        .editor-btn-success:hover {
            background: #1e7e34;
        }

        .editor-btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .editor-btn-warning:hover {
            background: #e0a800;
        }

        .editor-btn-danger {
            background: #dc3545;
            color: white;
        }

        .editor-btn-danger:hover {
            background: #c82333;
        }

        .editor-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .viewer-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #f0f0f0;
        }

        .pdf-viewer {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }

        .pdf-viewer.dragging {
            cursor: grabbing;
        }
        
        .pdf-area-outline {
            position: absolute;
            border: none;
            background: transparent;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .pdf-area-outline.active {
            border-color: #4ecdc4;
            background: transparent;
        }
        
        .simple-multiple-records {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .simple-multiple-records h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }
        
        .records-info {
            margin-top: 10px;
            padding: 8px 12px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 12px;
            color: #495057;
            font-weight: 500;
        }
        
        .multiple-textboxes-section {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .multiple-textboxes-section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }
        
        .multiple-textboxes-section h4 {
            margin: 10px 0 10px 0;
            font-size: 14px;
            color: #555;
        }
        
        .textbox-mapping-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .textbox-mapping-item label {
            font-size: 12px;
            color: #666;
            min-width: 80px;
        }
        
        .textbox-mapping-item select {
            flex: 1;
            font-size: 12px;
            padding: 4px;
        }

        .pdf-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            transition: transform 0.1s ease;
        }



        .pdf-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .pdf-control-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .pdf-control-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .lock-icon {
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .lock-text {
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .pdf-control-btn:hover .lock-icon {
            transform: scale(1.1);
        }

        .pdf-control-btn:hover .lock-text {
            color: #ffd700;
        }

        .pdf-control-btn:disabled {
            background: rgba(0, 0, 0, 0.3);
            cursor: not-allowed;
        }


        .no-pdf {
            text-align: center;
            color: #666;
            padding: 40px;
        }

        .no-pdf h3 {
            margin-bottom: 10px;
            color: #333;
        }

        #viewer {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background: white;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .loading {
            text-align: center;
            color: #666;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Layout Editor Styles */
        .editor-sidebar {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 250px;
            background: white;
            border-left: 1px solid #ddd;
            padding: 15px;
            overflow-y: auto;
            display: none;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
        }

        .editor-sidebar.active {
            display: block;
        }

        .editor-sidebar h4 {
            font-size: 12px;
            margin-bottom: 10px;
            color: #333;
        }

        .editor-form-group {
            margin-bottom: 10px;
        }

        .editor-form-group label {
            display: block;
            margin-bottom: 3px;
            font-size: 10px;
            color: #666;
        }

        .editor-form-group input, .editor-form-group select, .editor-form-group textarea {
            width: 100%;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
        }

        .editor-form-group textarea {
            height: 40px;
            resize: vertical;
        }

        .grid-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .grid-toggle label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            cursor: pointer;
        }

        .grid-toggle input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .editor-status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
        }

        /* Fabric.js canvas styling */
        .canvas-container {
            position: relative;
            display: inline-block;
        }

        #editorCanvas {
            border: 1px solid #ddd;
            background: transparent;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            z-index: 10;
        }

        /* Visual feedback for placement mode */
        .placement-mode {
            background: rgba(0, 123, 255, 0.1) !important;
            border: 2px dashed #007bff !important;
        }

        /* Enhanced text box styles */
        .draggable-text-box {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #007bff;
            padding: 5px;
            cursor: move;
            min-width: 80px;
            min-height: 25px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: #000;
            text-align: center;
            user-select: none;
            z-index: 20;
            transition: all 0.1s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: block;
            overflow: hidden;
            word-wrap: break-word;
            white-space: normal;
            line-height: 1.2;
        }

        .draggable-text-box.selected .resize-handle {
            background: #007bff !important;
        }



        /* Image box styles - matching MERGE-ONLINE behavior */
        .draggable-image-box {
            position: absolute;
            border: 2px dashed #007bff;
            background: rgba(255,255,255,0.2);
            cursor: move;
            z-index: 10;
            overflow: hidden;
            min-width: 40px;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .draggable-image-box.selected {
            border: 2px solid #007bff;
            background: rgba(0,123,255,0.08);
        }

        .draggable-image-box.selected .resize-handle {
            background: #007bff !important;
        }

        .draggable-image-box img {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: contain !important;
            object-position: center;
            aspect-ratio: auto;
            image-rendering: auto;
        }
        
        /* Force aspect ratio preservation for all image box sizes */
        .draggable-image-box img[style*="object-fit"] {
            object-fit: contain !important;
            object-position: center !important;
            aspect-ratio: auto !important;
        }

        /* Ensure resize handles are visible for image boxes */
        .draggable-image-box .resize-handle {
            display: block !important;
            opacity: 1 !important;
        }

        .draggable-text-box:hover {
            border-color: #0056b3;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .draggable-text-box:focus {
            outline: none;
            border-color: #28a745;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.25);
        }

        .draggable-text-box.resizing {
            border-color: #ff6b35;
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.25);
        }



        /* Snap-to-Grid Styles */
        .snap-guide {
            position: absolute;
            background: #007bff;
            opacity: 0.6;
            z-index: 1000;
            pointer-events: none;
            transition: opacity 0.1s ease;
        }

        .snap-guide.vertical {
            width: 1px;
            height: 100%;
        }

        .snap-guide.horizontal {
            width: 100%;
            height: 1px;
        }

        .snap-guide.active {
            opacity: 0.8;
            background: #28a745;
        }


    </style>
</head>
<body>
    <!-- Landing Page -->
    <div class="landing-page" id="landingPage">
        <header class="landing-header">
            <nav class="landing-nav landing-container">
                <a href="#" class="landing-logo">DataMerge</a>
                <ul class="landing-nav-links">
                    <li><a href="#features">Features</a></li>
                    <li><a href="#how-it-works">How It Works</a></li>
                    <li><a href="#benefits">Benefits</a></li>
                </ul>
                <button class="landing-cta-button" onclick="showApp()">Get Started Free</button>
            </nav>
        </header>

        <section class="landing-hero">
            <div class="landing-container">
                <h1>DataMerge</h1>
                <p class="subtitle">The Ultimate PDF Data Merging Tool - Convert CSV Data to Professional PDFs with Drag-and-Drop Simplicity</p>
                <div class="landing-hero-buttons">
                    <button class="landing-btn-primary" onclick="showApp()">
                        <i class="fas fa-play"></i> Try DataMerge Now
                    </button>
                    <button class="landing-btn-secondary" onclick="scrollToSection('how-it-works')">
                        <i class="fas fa-info-circle"></i> Learn More
                    </button>
                </div>
            </div>
        </section>

        <section class="landing-features" id="features">
            <div class="landing-container">
                <h2 class="landing-section-title">Powerful Features for Professional Document Generation</h2>
                <div class="landing-features-grid">
                    <div class="landing-feature-card">
                        <div class="landing-feature-icon">
                            <i class="fas fa-drag"></i>
                        </div>
                        <h3>Drag & Drop Interface</h3>
                        <p>Intuitive drag-and-drop interface makes it easy to position text and image elements on your PDF templates. No technical skills required.</p>
                    </div>
                    <div class="landing-feature-card">
                        <div class="landing-feature-icon">
                            <i class="fas fa-file-csv"></i>
                        </div>
                        <h3>CSV Data Integration</h3>
                        <p>Seamlessly import CSV data and automatically populate your PDF templates. Perfect for bulk document generation and mail merge operations.</p>
                    </div>
                    <div class="landing-feature-card">
                        <div class="landing-feature-icon">
                            <i class="fas fa-images"></i>
                        </div>
                        <h3>Image Support</h3>
                        <p>Add and position images dynamically from your CSV data. Perfect for certificates, ID cards, and personalized documents.</p>
                    </div>
                    <div class="landing-feature-card">
                        <div class="landing-feature-icon">
                            <i class="fas fa-download"></i>
                        </div>
                        <h3>Bulk Download</h3>
                        <p>Generate hundreds of PDFs at once and download them as a convenient ZIP file. Optimized for speed and efficiency.</p>
                    </div>
                    <div class="landing-feature-card">
                        <div class="landing-feature-icon">
                            <i class="fas fa-palette"></i>
                        </div>
                        <h3>Custom Styling</h3>
                        <p>Customize fonts, colors, and positioning to match your brand. Create professional-looking documents that impress your clients.</p>
                    </div>
                    <div class="landing-feature-card">
                        <div class="landing-feature-icon">
                            <i class="fas fa-shield-alt"></i>
                        </div>
                        <h3>Secure & Private</h3>
                        <p>Your data stays secure. All processing happens in your browser - no data is sent to our servers. Complete privacy guaranteed.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="landing-how-it-works" id="how-it-works">
            <div class="landing-container">
                <h2 class="landing-section-title">How DataMerge Works</h2>
                <div class="landing-steps">
                    <div class="landing-step">
                        <div class="landing-step-number">1</div>
                        <h3>Upload Your Template</h3>
                        <p>Upload your PDF template or start with a blank page. Our tool supports any PDF format.</p>
                    </div>
                    <div class="landing-step">
                        <div class="landing-step-number">2</div>
                        <h3>Add Your Data</h3>
                        <p>Upload your CSV file with all the data you want to merge. Our tool automatically detects columns.</p>
                    </div>
                    <div class="landing-step">
                        <div class="landing-step-number">3</div>
                        <h3>Design Your Layout</h3>
                        <p>Drag and drop text boxes and image placeholders onto your template. Position them exactly where you want.</p>
                    </div>
                    <div class="landing-step">
                        <div class="landing-step-number">4</div>
                        <h3>Generate & Download</h3>
                        <p>Click generate and download all your personalized PDFs in a single ZIP file. It's that simple!</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="landing-benefits" id="benefits">
            <div class="landing-container">
                <h2 class="landing-section-title">Why Choose DataMerge?</h2>
                <div class="landing-benefits-grid">
                    <div class="landing-benefit-item">
                        <div class="landing-benefit-icon">
                            <i class="fas fa-clock"></i>
                        </div>
                        <h3>Save Time</h3>
                        <p>Generate hundreds of personalized documents in minutes instead of hours. Automate your document workflow.</p>
                    </div>
                    <div class="landing-benefit-item">
                        <div class="landing-benefit-icon">
                            <i class="fas fa-dollar-sign"></i>
                        </div>
                        <h3>Reduce Costs</h3>
                        <p>Eliminate the need for expensive document automation software. DataMerge is completely free to use.</p>
                    </div>
                    <div class="landing-benefit-item">
                        <div class="landing-benefit-icon">
                            <i class="fas fa-users"></i>
                        </div>
                        <h3>Perfect for Teams</h3>
                        <p>Ideal for HR departments, marketing teams, and businesses that need to generate personalized documents at scale.</p>
                    </div>
                    <div class="landing-benefit-item">
                        <div class="landing-benefit-icon">
                            <i class="fas fa-mobile-alt"></i>
                        </div>
                        <h3>Works Everywhere</h3>
                        <p>Runs in any modern web browser. No software installation required. Access from any device, anywhere.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Privacy Policy Modal -->
        <div class="privacy-modal" id="privacyModal">
            <div class="privacy-modal-content">
                <div class="privacy-modal-header">
                    <h2>Privacy Policy</h2>
                    <button class="privacy-close" onclick="closePrivacyModal()">&times;</button>
                </div>
                <div class="privacy-modal-body">
                    <p><strong>Last Updated:</strong> December 2024</p>
                    
                    <h3>1. Information We Collect</h3>
                    <p>DataMerge is designed with privacy in mind. We do not collect, store, or transmit any of your personal data or files. All processing happens locally in your browser.</p>
                    
                    <h3>2. How We Use Your Information</h3>
                    <p>Since we don't collect any personal information, there is no data to use, share, or sell. Your files and data remain completely private and secure on your device.</p>
                    
                    <h3>3. Data Processing</h3>
                    <p>All PDF generation, CSV processing, and document merging occurs entirely within your web browser. No data is sent to our servers or any third-party services.</p>
                    
                    <h3>4. Cookies and Tracking</h3>
                    <p>We may use essential cookies to improve your experience, but we do not use tracking cookies or collect analytics data about your usage.</p>
                    
                    <h3>5. Third-Party Services</h3>
                    <p>DataMerge uses only essential third-party libraries (PDF.js, PDF-lib) that operate locally in your browser. No data is transmitted to these services.</p>
                    
                    <h3>6. Data Security</h3>
                    <p>Your data is secure because it never leaves your device. All processing is done locally, ensuring complete privacy and security.</p>
                    
                    <h3>7. Children's Privacy</h3>
                    <p>DataMerge is safe for users of all ages. Since we don't collect any personal information, there are no privacy concerns for children.</p>
                    
                    <h3>8. Changes to This Policy</h3>
                    <p>We may update this privacy policy from time to time. Any changes will be posted on this page with an updated revision date.</p>
                    
                    <h3>9. Contact Us</h3>
                    <p>If you have any questions about this privacy policy, please contact us through our website.</p>
                    
                    <h3>10. Compliance</h3>
                    <p>DataMerge complies with GDPR, CCPA, and other privacy regulations by design - we simply don't collect any personal data to begin with.</p>
                </div>
            </div>
        </div>

        <footer class="landing-footer">
            <div class="landing-container">
                <div class="landing-footer-content">
                    <div class="landing-footer-section">
                        <h3>DataMerge</h3>
                        <p>The ultimate PDF data merging tool for professionals. Convert CSV data to beautiful PDFs with ease.</p>
                    </div>
                    <div class="landing-footer-section">
                        <h3>Features</h3>
                        <ul>
                            <li><a href="#features">PDF Data Merging</a></li>
                            <li><a href="#features">CSV to PDF</a></li>
                            <li><a href="#features">Bulk Generation</a></li>
                            <li><a href="#features">Drag & Drop</a></li>
                        </ul>
                    </div>
                    <div class="landing-footer-section">
                        <h3>Use Cases</h3>
                        <ul>
                            <li><a href="#">Certificate Generation</a></li>
                            <li><a href="#">Invoice Creation</a></li>
                            <li><a href="#">ID Card Printing</a></li>
                            <li><a href="#">Mail Merge</a></li>
                        </ul>
                    </div>
                    <div class="landing-footer-section">
                        <h3>Legal</h3>
                        <ul>
                            <li><a href="#" onclick="openPrivacyModal()">Privacy Policy</a></li>
                            <li><a href="#">Terms of Service</a></li>
                            <li><a href="#">Contact Us</a></li>
                        </ul>
                    </div>
                </div>
                <div class="landing-footer-bottom">
                    <p>&copy; 2024 DataMerge. All rights reserved. | Professional PDF Data Merging Tool</p>
                </div>
            </div>
        </footer>
    </div>

    <!-- Image Loading Progress Overlay -->
    <div class="image-loading-overlay" id="imageLoadingOverlay">
        <div class="image-loading-content">
            <div class="image-loading-title">
                <span class="image-loading-spinner"></span>
                Loading Images...
            </div>
            <div class="image-loading-subtitle" id="imageLoadingSubtitle">
                Preparing images for PDF generation
            </div>
            <div class="image-progress-container">
                <div class="image-progress-bar" id="imageProgressBar"></div>
            </div>
            <div class="image-progress-text" id="imageProgressText">0%</div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-content">
                <!-- Back to Landing Button -->
                <div class="section" style="margin-bottom: 20px;">
                    <button onclick="showLanding()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: transform 0.2s ease;">
                        <i class="fas fa-home"></i> Back to Landing Page
                    </button>
                </div>

                <!-- File Uploads -->
                <div class="section">
                    <div class="form-group">
                    <label class="file-input" for="pdfFile">
                        <input type="file" id="pdfFile" accept="application/pdf">
                            <div id="fileLabel">📄 Click to select PDF file</div>
                    </label>
                    </div>
                    
                    <div class="form-group">
                    <label class="file-input" for="csvFile">
                        <input type="file" id="csvFile" accept=".csv,text/csv">
                            <div id="csvLabel">📊 Click to select CSV file</div>
                    </label>
                    </div>
                </div>

                <!-- Add Box Buttons (Above Layout Editor) -->
                <div class="section" style="margin-bottom: 20px;">
                    <div class="box-type-buttons" style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="btn btn-primary" onclick="addText()">Add Text Box(es)</button>
                        <button class="btn btn-secondary" onclick="addImagePlaceholder()">Add Image Box(es)</button>
                    </div>
                    
                    <!-- Box Count Selection -->
                    <div class="form-group" style="margin-top: 10px;">
                        <label>Number of Records:</label>
                        <select id="boxCountSelect" class="form-control">
                            <option value="1">1 Record</option>
                            <option value="2">2 Records</option>
                            <option value="3">3 Records</option>
                            <option value="4">4 Records</option>
                            <option value="5">5 Records</option>
                            <option value="6">6 Records</option>
                            <option value="8">8 Records</option>
                            <option value="10">10 Records</option>
                            <option value="12">12 Records</option>
                            <option value="15">15 Records</option>
                            <option value="20">20 Records</option>
                            </select>
                            </div>
                        </div>
                        
                        <!-- Record Info Display -->
                        <div id="recordInfoDisplay" class="record-info-display" style="border-top: 1px solid #e9ecef; padding: 14px 16px; background: #ffffff; margin-bottom: 12px; display: none; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); border: 1px solid #f0f0f0;">
                            <div id="recordInfoText" style="font-size: 14px; color: #2c3e50; font-weight: 600; letter-spacing: 0.2px; text-align: center; width: 100%;">
                                No box selected
                            </div>
                        </div>
                        
                        <!-- Page Navigation -->
                <div id="pageNavigation" class="page-navigation" style="border-top: 1px solid #e9ecef; padding: 12px; background: #f8f9fa; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
                        <button id="prevPageBtn" class="btn btn-sm btn-outline-secondary" onclick="previousPage()" style="font-size: 11px; padding: 4px 8px; min-width: 60px;">
                            ← Prev
                                </button>
                        <div style="text-align: center; flex: 1;">
                            <div id="pageInfo" style="font-size: 11px; color: #495057; font-weight: 500;">
                                    Page 1 of 1
                            </div>
                            <div id="pageRecordsInfo" style="font-size: 10px; color: #6c757d;">
                                Records 1-4
                            </div>
                        </div>
                        <button id="nextPageBtn" class="btn btn-sm btn-outline-secondary" onclick="nextPage()" style="font-size: 11px; padding: 4px 8px; min-width: 60px;">
                            Next →
                        </button>
                    </div>
                </div>

                <!-- Compact Layout Editor -->
                <div class="section">
                    <!-- Font Upload -->
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="font-size: 12px; font-weight: bold; color: #333;">Add Font:</label>
                        <div class="font-upload-area" id="fontUploadArea" style="height: 50px; font-size: 11px; border: 2px dashed #007bff; border-radius: 6px; background: #f8f9fa; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease;">
                            <input type="file" id="fontUploadInput" accept=".ttf,.otf" style="display: none;">
                            <div class="font-upload-content" style="text-align: center;">
                                <p style="margin: 0; font-size: 11px; color: #495057;">Drop TTF/OTF file here or click to browse</p>
                            </div>
                        </div>
                        <div id="fontUploadStatus" class="font-status" style="font-size: 10px;"></div>
                        </div>
                        
                    <!-- CSV Column Selection -->
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label style="font-size: 12px; font-weight: bold;">CSV Column:</label>
                        <select id="boxColumnSelect" class="form-control" style="font-size: 11px; padding: 4px 8px;">
                                        <option value="">Select CSV column...</option>
                                    </select>
                                </div>
                                
                    <!-- Apply Mode Toggle -->
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label style="font-size: 12px; font-weight: bold;">Apply To:</label>
                        <div style="display: flex; gap: 4px;">
                            <button type="button" id="applyToAllBtn" class="btn btn-sm btn-outline-secondary" style="flex: 1; font-size: 10px; padding: 4px 6px;" onclick="setApplyMode('all')">All Boxes</button>
                            <button type="button" id="applyToSelectedBtn" class="btn btn-sm btn-primary" style="flex: 1; font-size: 10px; padding: 4px 6px;" onclick="setApplyMode('selected')">Selected Only</button>
                                </div>
                                </div>
                                
                    <!-- Compact Formatting Controls -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 11px;">Font:</label>
                            <select id="formatAllFontFamily" class="form-control" style="font-size: 11px; padding: 4px 6px;" onchange="applyLiveFormatting()">
                                        <option value="Arial">Arial</option>
                                        <option value="Helvetica">Helvetica</option>
                                <option value="Times New Roman">Times New Roman</option>
                                        <option value="Georgia">Georgia</option>
                                        <option value="Verdana">Verdana</option>
                                        <option value="Courier New">Courier New</option>
                                <option value="Impact">Impact</option>
                                <option value="Comic Sans MS">Comic Sans MS</option>
                                    </select>
                                </div>
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 11px;">Size:</label>
                            <input type="number" id="formatAllFontSize" class="form-control" value="16" min="1" max="72" style="font-size: 11px; padding: 4px 6px;" onchange="applyLiveFormatting()">
                                    </div>
                                </div>
                                
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 11px;">Color:</label>
                            <input type="color" id="formatAllTextColor" class="form-control" value="#000000" style="height: 30px; padding: 2px;" onchange="applyLiveFormatting()">
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 11px;">Align:</label>
                            <select id="formatAllTextAlign" class="form-control" style="font-size: 11px; padding: 4px 6px;" onchange="applyLiveFormatting()">
                                        <option value="left">Left</option>
                                        <option value="center" selected>Center</option>
                                        <option value="right">Right</option>
                                <option value="justify">Justify</option>
                                    </select>
                        </div>
                                </div>
                                
                    <!-- Text Style Buttons -->
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label style="font-size: 11px;">Style:</label>
                        <div style="display: flex; gap: 4px;">
                                            <button type="button" id="formatAllBold" class="btn btn-sm btn-outline-secondary" style="flex: 1; font-size: 10px; padding: 4px 6px;">B</button>
                <button type="button" id="formatAllItalic" class="btn btn-sm btn-outline-secondary" style="flex: 1; font-size: 10px; padding: 4px 6px;">I</button>
                <button type="button" id="formatAllUnderline" class="btn btn-sm btn-outline-secondary" style="flex: 1; font-size: 10px; padding: 4px 6px;">U</button>
                                    </div>
                                </div>

                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                                </div>
                            </div>
                            




                            



            </div>
        </div>

        <div class="main-content">
            <div class="content-header">
                <div class="preview-controls" style="margin-bottom: 15px;">
                    <button id="previewModeBtn" class="btn btn-outline-primary" onclick="togglePreviewMode()" style="font-weight: 500;" title="Toggle Preview Mode - See exactly what your PDF will look like when downloaded (Press P key)">
                        Preview Mode
                    </button>
                </div>
                
                <div class="download-buttons" style="display: flex; gap: 10px; justify-content: flex-end; margin-bottom: 15px;">
                    <button id="screenshotBtn" class="btn btn-primary" onclick="downloadCurrentPdf()">
                        📄 Download Current PDF
                    </button>
                    
                    <button id="downloadPdfsBtn" class="btn btn-success" onclick="downloadPdfs()" disabled>
                        📦 Download All PDFs (ZIP)
                    </button>
                    
                    <button class="btn btn-danger" onclick="deleteSelectedBox()" id="deleteBoxBtn" disabled title="Delete selected box (or press Delete key)">
                        🗑️ Delete
                    </button>
                </div>
            </div>

            <div class="viewer-container">
                <div id="noPdf" class="no-pdf">
                    <h3>No PDF selected</h3>
                    <p>Choose a PDF file to start viewing</p>
                </div>

                <div id="loadingPdf" class="loading" style="display: none;">
                    <div class="spinner"></div>
                    <p>Loading PDF...</p>
                </div>

                <div id="pdfViewer" class="pdf-viewer" style="display: none;">
                    <div class="pdf-controls">
                        <button class="pdf-control-btn" onclick="togglePDFLock()" title="Lock PDF" id="pdfLockBtn">
                            <span class="lock-icon">🔒</span>
                            <span class="lock-text">Lock PDF</span>
                        </button>
                    </div>
                    
                                    <div class="pdf-content" id="pdfContent">
                    <canvas id="viewer"></canvas>
                        <canvas id="editorCanvas" style="display: none;"></canvas>
                    <div id="pdfAreaOutline" class="pdf-area-outline" style="display: none;"></div>
                </div>
                </div>
            </div>



            <!-- Editor Properties Sidebar -->
            <div id="editorSidebar" class="editor-sidebar">
                <h4>Object Properties</h4>
                
                <div class="editor-form-group">
                    <label>Bind to CSV Field:</label>
                    <select id="bindField">
                        <option value="">None (Static)</option>
                        <option value="title">Title</option>
                        <option value="subtitle">Subtitle</option>
                        <option value="price">Price</option>
                        <option value="features">Features</option>
                        <option value="image">Image</option>
                    </select>
                </div>

                <div class="editor-form-group">
                    <label>Static Content:</label>
                    <textarea id="staticContent" placeholder="Enter static text content..."></textarea>
                </div>

                <div class="editor-form-group">
                    <label>Position X:</label>
                    <input type="number" id="posX" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Position Y:</label>
                    <input type="number" id="posY" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Width:</label>
                    <input type="number" id="width" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Height:</label>
                    <input type="number" id="height" step="1">
                </div>
            </div>
            
        </div>
    </div>

    <script>
        // Landing Page Functions
        function showApp() {
            document.getElementById('landingPage').classList.remove('show');
            document.getElementById('mainApp').style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        function showLanding() {
            document.getElementById('landingPage').classList.add('show');
            document.getElementById('mainApp').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.scrollIntoView({ behavior: 'smooth' });
            }
        }

        function openPrivacyModal() {
            document.getElementById('privacyModal').classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function closePrivacyModal() {
            document.getElementById('privacyModal').classList.remove('show');
            document.body.style.overflow = 'auto';
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('privacyModal');
            if (event.target === modal) {
                closePrivacyModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closePrivacyModal();
            }
        });

        // Show landing page by default
        document.addEventListener('DOMContentLoaded', function() {
            showLanding();
        });

        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let currentPdf = null;
        let currentFile = null;
        let serverPdfUrl = null;

        // Session state management
        let sessionState = {
            templatePdf: null,
            templatePdfBytes: null,
            csv: null,
            csvRows: [],
            layout: null,
            boxes: [],
            selectedBox: null
        };

        // Enhanced box management system
        let boxCounter = 0;
        let currentBoxId = null;
        
        // Font management system
        let availableFonts = ['Arial', 'Times New Roman', 'Helvetica', 'Georgia', 'Verdana', 'Courier New'];
// Initialize sessionState fonts
if (!sessionState.availableFonts) {
    sessionState.availableFonts = [...availableFonts];
}
if (!sessionState.defaultFontFamily) {
    sessionState.defaultFontFamily = 'Arial';
}
        let loadedFonts = {};
        let defaultFontFamily = 'Arial';
        
        // CSV data management
        let currentRecord = 0;
        let csvData = null;

        // Editor canvas management
        let editorCanvas = null;
        
        // PDF viewer management
        let pdfViewer = null;
        let pdfContent = null;
        let pdfLocked = true; // PDF is locked by default when uploaded
        let isEditorMode = false;
        
        // PDF transform management
        let currentTransform = { x: 0, y: 0, scale: 1 };
        
        // PDF dragging state
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };


        
        // Initialize editor canvas
        function initEditorCanvas() {
            if (editorCanvas) return; // Already initialized
            
            const canvasElement = document.getElementById('editorCanvas');
            if (!canvasElement) {
                console.error('Editor canvas element not found');
                return;
            }
            
            // Set canvas size to match PDF viewer
            const pdfViewer = document.getElementById('pdfViewer');
            if (pdfViewer) {
                const rect = pdfViewer.getBoundingClientRect();
                canvasElement.width = rect.width;
                canvasElement.height = rect.height;
            }
            
            // Initialize Fabric.js canvas
            editorCanvas = new fabric.Canvas('editorCanvas', {
                selection: true,
                preserveObjectStacking: true
            });
            
            // Set canvas position to overlay PDF
            canvasElement.style.position = 'absolute';
            canvasElement.style.top = '20px';
            canvasElement.style.left = '20px';
            canvasElement.style.pointerEvents = 'auto';
            canvasElement.style.zIndex = '15';
            
            // Make canvas visible when in editor mode
            canvasElement.style.display = 'block';
            
            // Set Fabric.js canvas dimensions to match
            editorCanvas.setDimensions({
                width: canvasElement.width,
                height: canvasElement.height
            });
            
            console.log('Editor canvas initialized');
        }

        // File input handler
        document.getElementById('pdfFile').addEventListener('change', function(e) {
            console.log('PDF file input changed');
            const file = e.target.files[0];
            if (file) {
                console.log('File selected:', file.name, file.type, file.size);
                
                // Validate file type
                if (file.type !== 'application/pdf') {
                    alert('Please select a PDF file');
                    return;
                }
                
                // Validate file size (25MB limit)
                if (file.size > 25 * 1024 * 1024) {
                    alert('File too large. Maximum size is 25MB');
                    return;
                }
                
                currentFile = file;
                document.getElementById('fileLabel').textContent = file.name;
                
                // Reset server PDF URL
                serverPdfUrl = null;

                // Upload PDF to server first, then load it
                console.log('Uploading PDF to server...');
                uploadPdfToServer(file);
            } else {
                console.log('No file selected');
            }
        });

        // Upload PDF to server
        async function uploadPdfToServer(file) {
            try {
                // Show upload progress
                document.getElementById('fileLabel').textContent = 'Uploading...';
                
                const formData = new FormData();
                formData.append('file', file);
                
                const response = await fetch('upload.php', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.ok) {
                    console.log('PDF uploaded successfully:', result.url);
                    serverPdfUrl = result.url;
                    document.getElementById('fileLabel').textContent = file.name + ' ✓';
                    
                    // Load PDF from server URL
                    await loadPdfFromUrl(result.url);
                } else {
                    throw new Error(result.error || 'Upload failed');
                }
            } catch (error) {
                console.error('Upload error:', error);
                alert('Failed to upload PDF: ' + error.message);
                document.getElementById('fileLabel').textContent = 'Upload failed - Click to select PDF file';
            }
        }

        async function loadPdf(file) {
            try {
                console.log('Loading PDF file:', file.name);
                
                // Show loading state
                console.log('Showing loading state');
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'none';
                document.getElementById('loadingPdf').style.display = 'block';

                // Read file as ArrayBuffer
                console.log('Reading file as ArrayBuffer');
                const arrayBuffer = await file.arrayBuffer();
                console.log('ArrayBuffer size:', arrayBuffer.byteLength);

                // Create a separate copy for PDF-lib BEFORE loading with PDF.js
                const templateBytes = new Uint8Array(arrayBuffer).slice();

                // Load PDF document with error handling
                console.log('Loading PDF with PDF.js...');
                const pdf = await pdfjsLib.getDocument({
                    data: arrayBuffer,
                    // Enhanced options for better compatibility
                    disableAutoFetch: false,
                    disableStream: false,
                    disableRange: false,
                    maxImageSize: 1024 * 1024 * 10, // 10MB max image size
                    isEvalSupported: false,
                    useSystemFonts: true,
                    cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
                    cMapPacked: true,
                    stopAtErrors: false,
                    verbosity: 0
                }).promise;
                
                // Store PDF info
                currentPdf = pdf;

                // Update session state with the separate copy
                sessionState.templatePdf = pdf;
                sessionState.templatePdfBytes = templateBytes;
                


                // Enable Generate From Template button
                // generateFromTemplateBtn was removed
                
                // Enable Download PDFs button if CSV and boxes are also loaded
                updateDownloadButtonState();
                
                // Update records info
                updateRecordsInfo();

                // Render the page (always page 1 for single-page PDFs)
                await renderPage(1);

                // Initialize simple editor after PDF is loaded
                initEditor();

                // Hide loading and noPdf message, show PDF viewer
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'block';
                
                // Initialize PDF dragging functionality
                initPDFDragging();
                
                // Initialize PDF lock status
                updatePDFLockStatus();
                
                // Update PDF area outline
                updatePdfAreaOutline();

            } catch (error) {
                console.error('Error loading PDF:', error);
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'block';
                document.getElementById('noPdf').innerHTML = `
                    <h3>Error loading PDF</h3>
                    <p>${error.message}</p>
                    <p>Please try a different PDF file or check the console for more details.</p>
                `;
                
                // Reset file input
                document.getElementById('pdfFile').value = '';
                document.getElementById('fileLabel').textContent = '📄 Click to select PDF file';
            }
        }

        async function loadPdfFromUrl(url) {
            try {
                // Fetch PDF from server
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Failed to fetch PDF from server');
                }
                
                const arrayBuffer = await response.arrayBuffer();

                // Load PDF document
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                // Store PDF info
                currentPdf = pdf;

                // Update session state
                sessionState.templatePdf = pdf;
                sessionState.templatePdfBytes = arrayBuffer.slice(0); // Create a copy to avoid detachment

                // Render the page (always page 1 for single-page PDFs)
                await renderPage(1);

                // Hide loading and noPdf message, show PDF viewer
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'block';
                
                // Initialize PDF dragging functionality
                initPDFDragging();

            } catch (error) {
                console.error('Error loading PDF from URL:', error);
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'block';
                document.getElementById('noPdf').innerHTML = `
                    <h3>Error loading PDF</h3>
                    <p>${error.message}</p>
                `;
            }
        }

        async function renderPage(pageNumber) {
            if (!currentPdf) return;

            try {
                // Get page
                const page = await currentPdf.getPage(pageNumber);

                // Set up canvas
                const canvas = document.getElementById('viewer');
                const context = canvas.getContext('2d');

                // Render PDF at high quality with dynamic scale for crisp display
                const devicePixelRatio = window.devicePixelRatio || 1;
                const highQualityScale = Math.max(2.0, devicePixelRatio); // At least 2x scale, or device pixel ratio
                const viewport = page.getViewport({scale: highQualityScale});
                
                // Enable high-quality rendering
                context.imageSmoothingEnabled = true;
                context.imageSmoothingQuality = 'high';

                // Set canvas dimensions to high-quality size
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                // Set canvas display size to fit viewer while maintaining aspect ratio
                const viewerContainer = document.querySelector('.viewer-container');
                const containerWidth = viewerContainer.clientWidth;
                const containerHeight = viewerContainer.clientHeight;
                
                // Calculate display scale based on the high-quality viewport
                const scaleX = containerWidth / viewport.width;
                const scaleY = containerHeight / viewport.height;
                const displayScale = Math.min(scaleX, scaleY, 1.0); // Don't scale up, only down
                
                // Set display size (this will be smaller than canvas dimensions due to high-quality scale)
                canvas.style.width = (viewport.width * displayScale) + 'px';
                canvas.style.height = (viewport.height * displayScale) + 'px';

                // Make sure canvas is visible
                canvas.style.display = 'block';

                // Render page at original quality
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };

                await page.render(renderContext).promise;

                // Debug canvas visibility after rendering
                const canvasRect = canvas.getBoundingClientRect();
                console.log('Canvas rendered successfully!');
                console.log('Canvas bounding rect:', canvasRect);
                console.log('Canvas computed styles:', {
                    position: getComputedStyle(canvas).position,
                    top: getComputedStyle(canvas).top,
                    left: getComputedStyle(canvas).left,
                    width: getComputedStyle(canvas).width,
                    height: getComputedStyle(canvas).height,
                    zIndex: getComputedStyle(canvas).zIndex,
                    display: getComputedStyle(canvas).display,
                    visibility: getComputedStyle(canvas).visibility
                });

                // Update editor canvas size to match the rendered PDF
                if (typeof editorCanvas !== 'undefined' && editorCanvas) {
                    updateEditorPageSize();
                }

                console.log('PDF rendered at original quality:', viewport.width, 'x', viewport.height);

            } catch (error) {
                console.error('Error rendering page:', error);
            }
        }
        
        // Update editor canvas size to match PDF
        function updateEditorPageSize() {
            if (!editorCanvas) return;
            
            const canvas = document.getElementById('viewer');
            const canvasElement = document.getElementById('editorCanvas');
            
            if (canvas && canvasElement) {
                // Get the display size of the PDF canvas
                const displayWidth = parseInt(canvas.style.width) || canvas.width;
                const displayHeight = parseInt(canvas.style.height) || canvas.height;
                
                // Update editor canvas size to match
                canvasElement.width = displayWidth;
                canvasElement.height = displayHeight;
                
                // Update Fabric.js canvas dimensions
                editorCanvas.setDimensions({
                    width: displayWidth,
                    height: displayHeight
                });
                
                // Re-render the canvas
                editorCanvas.renderAll();
                
                console.log('Editor canvas resized to:', displayWidth, 'x', displayHeight);
            }
        }

        // Drag and drop support
        const uploadArea = document.querySelector('.sidebar');
        const fileInput = document.getElementById('pdfFile');

        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '#e3f2fd';
        });

        uploadArea.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '';
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '';
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                fileInput.files = files;
                currentFile = files[0];
                document.getElementById('fileLabel').textContent = files[0].name;
                
                // Reset server PDF URL
                serverPdfUrl = null;

                // Upload PDF to server first, then load it
                uploadPdfToServer(files[0]);
            }
        });


        
        // Initialize snap-to-grid toggle
        const snapToGridToggle = document.getElementById('snapToGridToggle');
        if (snapToGridToggle) {
            snapToGridToggle.addEventListener('change', function() {
                snapToGridEnabled = this.checked;
                console.log('Snap to grid:', snapToGridEnabled ? 'enabled' : 'disabled');
            });
        }
        
        // Smart JPEG quality optimization for target file size (fontmerge approach)
        async function optimizeImageQuality(canvas, targetSizeBytes = 2.0 * 1024 * 1024) { // 2MB target for higher quality
            const maxIterations = 10;
            let quality = 0.95; // Start with high quality
            let minQuality = 0.7; // Minimum acceptable quality
            let bestQuality = quality;
            let bestSize = 0;
            
            for (let i = 0; i < maxIterations; i++) {
                const testDataUrl = canvas.toDataURL('image/jpeg', quality);
                const sizeBytes = (testDataUrl.length - 22) * 3 / 4; // Approximate byte size
                
                // Check if size is within target range (1.5MB-2.5MB for higher quality)
                if (sizeBytes >= 1.5 * 1024 * 1024 && sizeBytes <= 2.5 * 1024 * 1024) {
                    return { dataUrl: testDataUrl, quality: quality, size: sizeBytes };
                }
                
                // If too large, reduce quality
                if (sizeBytes > 2.5 * 1024 * 1024) {
                    quality = Math.max(quality - 0.05, minQuality);
                }
                // If too small, increase quality (but don't exceed 0.95)
                else if (sizeBytes < 1.5 * 1024 * 1024) {
                    quality = Math.min(quality + 0.02, 0.95);
                }
                
                // Track best quality within acceptable range
                if (sizeBytes <= 2.5 * 1024 * 1024 && quality > bestQuality) {
                    bestQuality = quality;
                    bestSize = sizeBytes;
                }
                
                // If we've hit minimum quality, use the best we found
                if (quality <= minQuality) {
                    const finalDataUrl = canvas.toDataURL('image/jpeg', bestQuality);
                    return { dataUrl: finalDataUrl, quality: bestQuality, size: bestSize };
                }
            }
            
            // Fallback to best quality found
            const finalDataUrl = canvas.toDataURL('image/jpeg', bestQuality);
            return { dataUrl: finalDataUrl, quality: bestQuality, size: bestSize };
        }

        // Function to compress canvas for smaller PDFs
        function compressCanvas(canvas, targetSize = 0.8) {
            const originalWidth = canvas.width;
            const originalHeight = canvas.height;
            
            // Calculate new dimensions (reduce by compression factor)
            const newWidth = Math.floor(originalWidth * targetSize);
            const newHeight = Math.floor(originalHeight * targetSize);
            
            // Create compressed canvas
            const compressedCanvas = document.createElement('canvas');
            compressedCanvas.width = newWidth;
            compressedCanvas.height = newHeight;
            
            const ctx = compressedCanvas.getContext('2d');
            ctx.drawImage(canvas, 0, 0, originalWidth, originalHeight, 0, 0, newWidth, newHeight);
            
            return compressedCanvas;
        }
        
        // Function to validate and optimize PDF size
        async function validateAndOptimizePdfSize(pdfBytes, recordNumber, totalRecords) {
            const MIN_SIZE = 1024 * 1024; // 1MB
            const MAX_SIZE = 1.5 * 1024 * 1024; // 1.5MB
            const currentSize = pdfBytes.length;
            
            console.log(`PDF ${recordNumber}/${totalRecords} size: ${(currentSize / 1024 / 1024).toFixed(2)}MB`);
            
            // If PDF is within acceptable range, return as-is
            if (currentSize >= MIN_SIZE && currentSize <= MAX_SIZE) {
                console.log(`✓ PDF ${recordNumber} size is acceptable: ${(currentSize / 1024 / 1024).toFixed(2)}MB`);
                return pdfBytes;
            }
            
            // If PDF is too small, we need to add content or increase quality
            if (currentSize < MIN_SIZE) {
                console.log(`⚠️ PDF ${recordNumber} is too small (${(currentSize / 1024 / 1024).toFixed(2)}MB). Adding content...`);
                // For now, we'll accept small PDFs but log a warning
                // In the future, we could add more content or increase image quality
                return pdfBytes;
            }
            
            // If PDF is too large, we need to compress it
            if (currentSize > MAX_SIZE) {
                console.log(`⚠️ PDF ${recordNumber} is too large (${(currentSize / 1024 / 1024).toFixed(2)}MB). Attempting aggressive compression...`);
                
                try {
                    // Load the PDF document
                    const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                    
                    // Try multiple compression strategies
                    let bestBytes = pdfBytes;
                    let bestSize = currentSize;
                    
                    // Strategy 1: Basic compression
                    try {
                        const compressed1 = await pdfDoc.save({
                            useObjectStreams: false,
                            addDefaultPage: false,
                            objectsPerTick: 50
                        });
                        if (compressed1.length < bestSize) {
                            bestBytes = compressed1;
                            bestSize = compressed1.length;
                        }
                    } catch (e) {}
                    
                    // Strategy 2: More aggressive compression
                    try {
                        const compressed2 = await pdfDoc.save({
                            useObjectStreams: true,
                            addDefaultPage: false,
                            objectsPerTick: 100
                        });
                        if (compressed2.length < bestSize) {
                            bestBytes = compressed2;
                            bestSize = compressed2.length;
                        }
                    } catch (e) {}
                    
                    // Strategy 3: Maximum compression
                    try {
                        const compressed3 = await pdfDoc.save({
                            useObjectStreams: true,
                            addDefaultPage: false,
                            objectsPerTick: 200,
                            updateFieldAppearances: false
                        });
                        if (compressed3.length < bestSize) {
                            bestBytes = compressed3;
                            bestSize = compressed3.length;
                        }
                    } catch (e) {}
                    
                    // Strategy 4: Ultra compression (if still too large)
                    if (bestSize > MAX_SIZE) {
                        try {
                            const compressed4 = await pdfDoc.save({
                                useObjectStreams: true,
                                addDefaultPage: false,
                                objectsPerTick: 500,
                                updateFieldAppearances: false,
                                compress: true
                            });
                            if (compressed4.length < bestSize) {
                                bestBytes = compressed4;
                                bestSize = compressed4.length;
                            }
                        } catch (e) {}
                    }
                    
                    const compressedSize = bestSize;
                    console.log(`Compressed PDF ${recordNumber}: ${(compressedSize / 1024 / 1024).toFixed(2)}MB (reduced by ${((currentSize - compressedSize) / currentSize * 100).toFixed(1)}%)`);
                    
                    if (compressedSize <= MAX_SIZE) {
                        console.log(`✓ PDF ${recordNumber} successfully compressed to acceptable size`);
                        return bestBytes;
                    } else {
                        console.log(`⚠️ PDF ${recordNumber} still too large after compression (${(compressedSize / 1024 / 1024).toFixed(2)}MB). Proceeding with warning.`);
                        return bestBytes; // Return best compressed version
                    }
                } catch (error) {
                    console.error(`Failed to compress PDF ${recordNumber}:`, error);
                    return pdfBytes; // Return original if compression fails
                }
            }
            
            return pdfBytes;
        }
        
        // Function to update download button state
        function updateDownloadButtonState() {
            const hasTemplate = sessionState.templatePdfBytes !== null;
            const hasCSV = sessionState.csvRows.length > 0;
            const hasBoxes = sessionState.boxes.length > 0;
            
            // Get the number of records selected from dropdown
            const boxCountSelect = document.getElementById('boxCountSelect');
            const selectedRecordCount = boxCountSelect ? parseInt(boxCountSelect.value) || 1 : 1;
            
            // Check if we have at least some boxes with CSV data (same logic as downloadPdfs)
            // Note: boxes use fieldKey instead of csvColumn
            const hasTextBoxes = sessionState.boxes.some(box => box.type === 'text' && (box.csvColumn || box.fieldKey));
            const hasImageBoxes = sessionState.boxes.some(box => box.boxType === 'image' && (box.csvColumn || box.fieldKey));
            const hasBoxesWithCSV = hasTextBoxes || hasImageBoxes;
            
            const downloadBtn = document.getElementById('downloadPdfsBtn');
            if (downloadBtn) {
                // Enable button only if we have template, CSV data, at least one box with CSV binding, AND only 1 record selected
                // Disable when more than 1 record to prevent system resource drain
                downloadBtn.disabled = !(hasTemplate && hasCSV && hasBoxesWithCSV) || selectedRecordCount > 1;
                
                // Update button text to show status
                if (!hasTemplate) {
                    downloadBtn.textContent = '📦 Download All PDFs (ZIP) - Missing PDF template';
                } else if (!hasCSV) {
                    downloadBtn.textContent = '📦 Download All PDFs (ZIP) - Missing CSV data';
                } else if (!hasBoxesWithCSV) {
                    downloadBtn.textContent = '📦 Download All PDFs (ZIP) - No CSV bindings';
                } else {
                    downloadBtn.textContent = `📦 Download All PDFs (ZIP) - ${sessionState.csvRows.length} records`;
                }
            }
        }
        
        // Function to update PDF area outline
        function updatePdfAreaOutline() {
            const canvas = document.getElementById('viewer');
            const outline = document.getElementById('pdfAreaOutline');
            
            if (!canvas || !outline) return;
            
            const rect = canvas.getBoundingClientRect();
            const viewerRect = document.getElementById('pdfViewer').getBoundingClientRect();
            
            // Calculate position relative to the viewer
            const left = rect.left - viewerRect.left;
            const top = rect.top - viewerRect.top;
            
            // Apply the same transform as the PDF content to keep outline aligned
            outline.style.transform = `translate(${currentTransform.x}px, ${currentTransform.y}px) scale(${currentTransform.scale})`;
            outline.style.transformOrigin = '0 0';
            
            // Set base position (before transform)
            outline.style.left = left + 'px';
            outline.style.top = top + 'px';
            outline.style.width = rect.width + 'px';
            outline.style.height = rect.height + 'px';
            outline.style.display = 'block';
            
            console.log(`PDF area outline updated: ${rect.width}x${rect.height} at (${left}, ${top}) with transform: scale(${currentTransform.scale})`);
            console.log(`Canvas actual size: ${canvas.width}x${canvas.height}, Display size: ${rect.width}x${rect.height}`);
        }
        
        // Update outline when zoom changes
        function updateOutlineOnZoom() {
            setTimeout(updatePdfAreaOutline, 100); // Small delay to ensure zoom is applied
        }
        
        // Field Selection Modal
        function showFieldSelectionModal(csvColumns, boxCount, boxType) {
            return new Promise((resolve) => {
                // Create modal overlay
                const modalOverlay = document.createElement('div');
                modalOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                // Create modal content
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: white;
                    padding: 30px;
                    border-radius: 10px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    width: 90%;
                    text-align: center;
                `;

                // Create title
                const title = document.createElement('h3');
                title.textContent = `Select CSV Field for ${boxCount} ${boxType === 'text' ? 'Text' : 'Image'} Boxes`;
                title.style.cssText = `
                    margin: 0 0 20px 0;
                    color: #333;
                    font-size: 18px;
                `;

                // Create description
                const description = document.createElement('p');
                description.textContent = `Choose which CSV field to use for all ${boxCount} boxes:`;
                description.style.cssText = `
                    margin: 0 0 20px 0;
                    color: #666;
                    font-size: 14px;
                `;

                // Create dropdown
                const dropdown = document.createElement('select');
                dropdown.style.cssText = `
                    width: 100%;
                    padding: 12px;
                    border: 2px solid #ddd;
                    border-radius: 6px;
                    font-size: 16px;
                    margin-bottom: 20px;
                    background: white;
                `;

                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Select a field --';
                defaultOption.disabled = true;
                defaultOption.selected = true;
                dropdown.appendChild(defaultOption);

                // Add CSV columns as options
                csvColumns.forEach(column => {
                    const option = document.createElement('option');
                    option.value = column;
                    option.textContent = column;
                    dropdown.appendChild(option);
                });

                // Create button container
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = `
                    display: flex;
                    gap: 10px;
                    justify-content: center;
                `;

                // Create OK button
                const okButton = document.createElement('button');
                okButton.textContent = 'Create Boxes';
                okButton.style.cssText = `
                    padding: 10px 20px;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 14px;
                `;
                okButton.onclick = () => {
                    const selectedValue = dropdown.value;
                    if (selectedValue) {
                        modalOverlay.remove();
                        resolve(selectedValue);
                    } else {
                        alert('Please select a field first.');
                    }
                };

                // Create Cancel button
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.style.cssText = `
                    padding: 10px 20px;
                    background: #6c757d;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 14px;
                `;
                cancelButton.onclick = () => {
                    modalOverlay.remove();
                    resolve(null);
                };

                // Add hover effects
                okButton.onmouseover = () => okButton.style.background = '#0056b3';
                okButton.onmouseout = () => okButton.style.background = '#007bff';
                cancelButton.onmouseover = () => cancelButton.style.background = '#545b62';
                cancelButton.onmouseout = () => cancelButton.style.background = '#6c757d';

                // Assemble modal
                buttonContainer.appendChild(okButton);
                buttonContainer.appendChild(cancelButton);
                modalContent.appendChild(title);
                modalContent.appendChild(description);
                modalContent.appendChild(dropdown);
                modalContent.appendChild(buttonContainer);
                modalOverlay.appendChild(modalContent);

                // Add to page
                document.body.appendChild(modalOverlay);

                // Focus on dropdown
                dropdown.focus();

                // Handle Enter key
                dropdown.onkeydown = (e) => {
                    if (e.key === 'Enter' && dropdown.value) {
                        okButton.click();
                    }
                };
            });
        }

        // Toggle Format Style Function
        function toggleFormatStyle(buttonId) {
            const button = document.getElementById(buttonId);
            if (button) {
                button.classList.toggle('active');
                button.style.background = button.classList.contains('active') ? '#007bff' : '';
                button.style.color = button.classList.contains('active') ? 'white' : '';
            }
        }

        // Update Font Dropdowns Function
        function updateFontDropdowns() {
            const fontSelects = [
                document.getElementById('formatAllFontFamily'),
                document.getElementById('boxFontFamily')
            ];
            
            fontSelects.forEach(select => {
                if (select) {
                    // Store current selection
                    const currentValue = select.value;
                    
                    // Clear existing options
                    select.innerHTML = '';
                    
                    // Add all available fonts
                    sessionState.availableFonts.forEach(fontName => {
                        const option = document.createElement('option');
                        option.value = fontName;
                        option.textContent = fontName;
                        select.appendChild(option);
                    });
                    
                    // Restore selection if it still exists, otherwise use default
                    if (sessionState.availableFonts.includes(currentValue)) {
                        select.value = currentValue;
                    } else if (sessionState.defaultFontFamily && sessionState.availableFonts.includes(sessionState.defaultFontFamily)) {
                        select.value = sessionState.defaultFontFamily;
                    }
                }
            });
        }

        // Format All Text Boxes Function
        function formatAllTextBoxes() {
            const textBoxes = sessionState.boxes.filter(box => box.boxType === 'text');
            
            if (textBoxes.length === 0) {
                alert('No text boxes found to format.');
                return;
            }
            
            // Get formatting values from the form
            const fontFamily = document.getElementById('formatAllFontFamily').value;
            const fontSize = document.getElementById('formatAllFontSize').value;
            const textColor = document.getElementById('formatAllTextColor').value;
            const textAlign = document.getElementById('formatAllTextAlign').value;
            
            // Get text style states
            const boldBtn = document.getElementById('formatAllBold');
            const italicBtn = document.getElementById('formatAllItalic');
            const underlineBtn = document.getElementById('formatAllUnderline');
            
            const isBold = boldBtn.classList.contains('active');
            const isItalic = italicBtn.classList.contains('active');
            const isUnderline = underlineBtn.classList.contains('active');

            // Apply formatting to all text boxes
            textBoxes.forEach(box => {
                if (box.element) {
                    const element = box.element;
                    
                    // Update element styles with proper font family formatting
                    element.style.fontFamily = `'${fontFamily}', Arial, sans-serif`;
                    element.style.fontSize = fontSize + 'px';
                    element.style.color = textColor;
                    element.style.textAlign = textAlign;
                    
                    // Apply text styles
                    element.style.fontWeight = isBold ? 'bold' : 'normal';
                    element.style.fontStyle = isItalic ? 'italic' : 'normal';
                    element.style.textDecoration = isUnderline ? 'underline' : 'none';
                    
                    // Update box data in session state
                    box.fontFamily = fontFamily;
                    box.fontSize = parseInt(fontSize);
                    box.color = textColor;
                    box.textAlign = textAlign;
                    box.bold = isBold;
                    box.italic = isItalic;
                    box.underline = isUnderline;
                }
            });

            // Show success message
            alert(`Applied formatting to ${textBoxes.length} text box(es)!`);
        }

        // Global variable for apply mode (default: selected only)
        let applyMode = 'selected';

        // Function to set apply mode (all boxes vs selected only)
        function setApplyMode(mode) {
            applyMode = mode;
            
            // Update button styles
            const allBtn = document.getElementById('applyToAllBtn');
            const selectedBtn = document.getElementById('applyToSelectedBtn');
            
            if (allBtn && selectedBtn) {
                if (mode === 'all') {
                    allBtn.className = 'btn btn-sm btn-primary';
                    selectedBtn.className = 'btn btn-sm btn-outline-secondary';
                } else {
                    allBtn.className = 'btn btn-sm btn-outline-secondary';
                    selectedBtn.className = 'btn btn-sm btn-primary';
                }
            }
        }

        // Function to apply live formatting instantly
        function applyLiveFormatting() {
            console.log('applyLiveFormatting called');
            console.log('Current applyMode:', applyMode);
            console.log('Selected box:', sessionState.selectedBox);
            
            // Get formatting values from the form
            const fontFamily = document.getElementById('formatAllFontFamily').value;
            const fontSize = document.getElementById('formatAllFontSize').value;
            const textColor = document.getElementById('formatAllTextColor').value;
            const textAlign = document.getElementById('formatAllTextAlign').value;
            
            // Get text style states
            const boldBtn = document.getElementById('formatAllBold');
            const italicBtn = document.getElementById('formatAllItalic');
            const underlineBtn = document.getElementById('formatAllUnderline');
            
            const isBold = boldBtn.classList.contains('active');
            const isItalic = italicBtn.classList.contains('active');
            const isUnderline = underlineBtn.classList.contains('active');
            
            console.log('Style states:', { isBold, isItalic, isUnderline });

            // Determine which boxes to format based on apply mode
            let boxesToFormat = [];
            if (applyMode === 'all') {
                boxesToFormat = sessionState.boxes.filter(box => box.boxType === 'text');
                console.log('Formatting ALL text boxes:', boxesToFormat.length);
            } else {
                // Format only selected box
                if (sessionState.selectedBox && sessionState.selectedBox.boxType === 'text') {
                    boxesToFormat = [sessionState.selectedBox];
                    console.log('Formatting SELECTED text box only:', sessionState.selectedBox);
                } else {
                    console.log('No selected text box to format');
                }
            }

            if (boxesToFormat.length === 0) {
                return; // No boxes to format
            }

            // Apply formatting to the determined boxes
            boxesToFormat.forEach(box => {
                if (box.element) {
                    const element = box.element;
                    
                    // Update element styles with proper font family formatting
                    element.style.fontFamily = `'${fontFamily}', Arial, sans-serif`;
                    element.style.fontSize = fontSize + 'px';
                    element.style.color = textColor;
                    element.style.textAlign = textAlign;
                    
                    // Apply text styles
                    element.style.fontWeight = isBold ? 'bold' : 'normal';
                    element.style.fontStyle = isItalic ? 'italic' : 'normal';
                    element.style.textDecoration = isUnderline ? 'underline' : 'none';
                    
                    // Update box data in session state
                    box.fontFamily = fontFamily;
                    box.fontSize = parseInt(fontSize);
                    box.color = textColor;
                    box.textAlign = textAlign;
                    box.bold = isBold;
                    box.italic = isItalic;
                    box.underline = isUnderline;
                }
            });
        }

        // Updated function to toggle format styles with live application
        function toggleFormatStyle(buttonId) {
            const button = document.getElementById(buttonId);
            if (button) {
                button.classList.toggle('active');
                button.style.background = button.classList.contains('active') ? '#007bff' : '';
                button.style.color = button.classList.contains('active') ? 'white' : '';
                
                // Apply formatting immediately after style toggle
                applyLiveFormatting();
            }
        }

        // Add event listeners for text style buttons
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize alignment dropdown to center by default
            const alignmentSelect = document.getElementById('formatAllTextAlign');
            if (alignmentSelect) {
                alignmentSelect.value = 'center';
            }

            // Bold button
            const boldBtn = document.getElementById('formatAllBold');
            if (boldBtn) {
                boldBtn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    if (this.classList.contains('active')) {
                        this.style.background = '#007bff';
                        this.style.color = 'white';
                        this.style.borderColor = '#007bff';
                    } else {
                        this.style.background = '';
                        this.style.color = '';
                        this.style.borderColor = '';
                    }
                    applyLiveFormatting(); // Apply formatting immediately
                });
            }

            // Italic button
            const italicBtn = document.getElementById('formatAllItalic');
            if (italicBtn) {
                italicBtn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    if (this.classList.contains('active')) {
                        this.style.background = '#007bff';
                        this.style.color = 'white';
                        this.style.borderColor = '#007bff';
                    } else {
                        this.style.background = '';
                        this.style.color = '';
                        this.style.borderColor = '';
                    }
                    applyLiveFormatting(); // Apply formatting immediately
                });
            }

            // Underline button
            const underlineBtn = document.getElementById('formatAllUnderline');
            if (underlineBtn) {
                underlineBtn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    if (this.classList.contains('active')) {
                        this.style.background = '#007bff';
                        this.style.color = 'white';
                        this.style.borderColor = '#007bff';
                    } else {
                        this.style.background = '';
                        this.style.color = '';
                        this.style.borderColor = '';
                    }
                    applyLiveFormatting(); // Apply formatting immediately
                });
            }

            // CSV file input handler
            const csvFileInput = document.getElementById('csvFile');
            console.log('Looking for CSV file input:', csvFileInput);
            if (csvFileInput) {
                console.log('CSV file input found, adding event listener');
                csvFileInput.addEventListener('change', function(e) {
                    console.log('CSV file selected:', e.target.files[0]);
                    const file = e.target.files[0];
                    if (file) {
                        parseCSVFile(file);
                    } else {
                        console.log('No file selected');
                    }
                });
            } else {
                console.error('CSV file input not found!');
            }

            // Setup keyboard shortcuts for box management
            setupKeyboardShortcuts();
        });

        // Simple Multiple Records Management
        let recordsCreated = 0;
        
        function createMultipleTextRecords() {
            // Check if CSV data is loaded
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }
            
            // Check if we have text boxes with CSV columns assigned
            const textBoxes = sessionState.boxes.filter(box => box.boxType === 'text' && box.csvColumn);
            
            if (textBoxes.length === 0) {
                alert('Please create at least one text box with a CSV field assigned!');
                return;
            }
            
            // Get the number of records to create from dropdown
            const recordsCount = parseInt(document.getElementById('recordsCountSelect').value);
            
            // Remove initial text boxes
            textBoxes.forEach(box => {
                if (box.element) {
                    box.element.remove();
                }
            });
            sessionState.boxes = sessionState.boxes.filter(box => box.boxType !== 'text');
            
            // Create multiple text boxes for each record
            for (let i = 0; i < recordsCount; i++) {
                if (i >= sessionState.csvRows.length) break; // Don't create more than available records
                
                const record = sessionState.csvRows[i];
                const verticalOffset = i * 120; // Space between record groups
                
                // Create text boxes
                textBoxes.forEach((templateBox, txtIndex) => {
                    // Create text box (existing logic)
                    const recordText = record[templateBox.csvColumn] || `Record ${i + 1}`;
                    
                const newBox = {
                        ...templateBox,
                    id: ++boxCounter,
                        boxId: boxCounter, // Add boxId for consistency with delete function
                        y: templateBox.y + verticalOffset, // Stack vertically with spacing
                        boxIndex: i, // Track which record this box represents
                    element: null
                };
                
                // Create the text box element
                const textBox = document.createElement('div');
                textBox.className = 'draggable-text-box';
                textBox.id = 'textBox_' + newBox.id;
                textBox.style.cssText = `
                    position: absolute;
                    left: ${newBox.x}px;
                    top: ${newBox.y}px;
                    width: ${newBox.width}px;
                    height: ${newBox.height}px;
                    min-width: 80px;
                    min-height: 25px;
                    background: transparent;
                    border: none;
                    padding: 5px;
                    cursor: move;
                    pointer-events: auto;
                    z-index: 20;
                    font-family: ${newBox.fontFamily}, sans-serif;
                    font-size: ${newBox.fontSize}px;
                    color: ${newBox.color};
                    text-align: ${newBox.textAlign};
                    user-select: none;
                    box-sizing: border-box;
                    overflow: hidden;
                    box-shadow: none;
                    transition: all 0.1s ease;
                    display: block;
                    line-height: 1.2;
                `;
                textBox.textContent = recordText;
                textBox.contentEditable = false;
                    

                
                // Add to overlay container
                const overlayContainer = document.getElementById('overlayContainer');
                overlayContainer.appendChild(textBox);
                
                // Make it draggable
                makeDraggable(textBox);
                
                // Add click handler
                textBox.addEventListener('click', function(e) {
                    e.stopPropagation();
                    // Remove selection from all boxes
                    document.querySelectorAll('.draggable-text-box, .draggable-image-box').forEach(box => {
                        box.style.border = 'none';
                        box.classList.remove('selected');
                    });
                    textBox.style.border = 'none';
                    textBox.classList.add('selected');
                    sessionState.selectedBox = newBox;
                    updateBoxEditor();
                    updateBoxEditorValues(newBox);
                    
                    // Show record info for the selected box
                    showRecordInfo(newBox);
                });
                
                newBox.element = textBox;
                sessionState.boxes.push(newBox);
                });
            }
            
            recordsCreated += recordsCount;
            updateRecordsInfo();
            
            // Reset to first page and update navigation
            currentPage = 0;
            updatePageNavigation();
            updateAllBoxesWithCSVData();
            
            const totalBoxes = textBoxes.length * recordsCount;
            alert(`Created ${totalBoxes} text boxes for ${recordsCount} records!`);
            
            // Update download button state to enable downloads
            updateDownloadButtonState();
            
            // Update text box scaling to match current PDF viewer state
            updateTextBoxScaling();
        }
        
        function updateRecordsInfo() {
            // recordsInfo element was removed with the Multiple Records section
            // This function is kept for compatibility but does nothing
        }
        
        function createMultipleImageRecords() {
            // Check if CSV data is loaded
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }
            
            // Check if we have image boxes with CSV columns assigned
            const imageBoxes = sessionState.boxes.filter(box => box.boxType === 'image' && box.csvColumn);
            
            if (imageBoxes.length === 0) {
                alert('Please create at least one image box with a CSV field assigned!');
                return;
            }
            
            // Get the number of records to create from dropdown
            const recordsCount = parseInt(document.getElementById('recordsCountSelect').value);
            
            // Remove initial image boxes
            imageBoxes.forEach(box => {
                if (box.parentNode) {
                    box.remove();
                }
            });
            sessionState.boxes = sessionState.boxes.filter(box => box.boxType !== 'image');
            
            // Create multiple image boxes for each record
            for (let i = 0; i < recordsCount; i++) {
                if (i >= sessionState.csvRows.length) break; // Don't create more than available records
                
                const record = sessionState.csvRows[i];
                const verticalOffset = i * 120; // Space between record groups
                
                // Create image boxes
                imageBoxes.forEach((templateBox, imgIndex) => {
                    // Create image box using DOM elements
                    const centerX = parseFloat(templateBox.style?.left) || 100;
                    const centerY = (parseFloat(templateBox.style?.top) || 100) + verticalOffset; // Stack vertically
                    
                    // Create a DOM-based image box
                    const imageBox = document.createElement('div');
                    imageBox.className = 'draggable-image-box';
                    imageBox.style.cssText = `
                        position: absolute;
                        left: ${(centerX - 50)}px;
                        top: ${(centerY - 50)}px;
                        width: 100px;
                        height: 100px;
                        border: 2px dashed #007bff;
                        background: transparent;
                        cursor: move;
                        z-index: 10;
                        overflow: hidden;
                        box-sizing: border-box;
                        transition: all 0.1s ease;
                    `;

                    // Add custom properties
                    imageBox.boxId = ++boxCounter;
                    imageBox.boxType = 'image';
                    imageBox.csvColumn = templateBox.csvColumn;
                    imageBox.imageSource = 'csv';
                    imageBox.imageUrl = '';
                    imageBox.boxIndex = i; // Track which record this box represents

                    // Add click handler for selection
                    imageBox.addEventListener('click', function(e) {
                        e.stopPropagation();
                        // Remove selection from all boxes
                        document.querySelectorAll('.draggable-image-box, .draggable-text-box').forEach(box => {
                            box.classList.remove('selected');
                        });
                        imageBox.classList.add('selected');
                        sessionState.selectedBox = imageBox;
                        currentBoxId = imageBox.boxId;
                        updateBoxEditor();
                        updateBoxEditorValues(imageBox);
                        
                        // Find the box data object and show record info
                        const boxData = sessionState.boxes.find(b => b.element === imageBox);
                        if (boxData) {
                            showRecordInfo(boxData);
                        }
                    });

                    // Add to PDF viewer and enable drag/resize
                    const pdfViewer = document.getElementById('pdfViewer');
                    pdfViewer.appendChild(imageBox);
                    enableDragResize(imageBox);
                    
                    // Create proper box data object
                    const imageBoxData = {
                        id: imageBox.boxId,
                        boxId: imageBox.boxId,
                        element: imageBox,
                        type: 'image',
                        boxType: 'image',
                        fieldKey: templateBox.csvColumn, // Use csvColumn as fieldKey
                        imageSource: 'csv',
                        imageUrl: '',
                        boxIndex: i, // Track which record this box represents
                        x: parseInt(imageBox.style.left),
                        y: parseInt(imageBox.style.top),
                        width: 100,
                        height: 100
                    };
                    
                    sessionState.boxes.push(imageBoxData);
                    
                    // Update the image with CSV data
                    const recordIndex = currentPage * recordsPerPage + (i % recordsPerPage);
                    updateImageBoxWithCSVData(imageBoxData, recordIndex);
                });
            }
            
            recordsCreated += recordsCount;
            updateRecordsInfo();
            
            // Reset to first page and update navigation
            currentPage = 0;
            updatePageNavigation();
            
            const totalBoxes = imageBoxes.length * recordsCount;
            alert(`Created ${totalBoxes} image boxes for ${recordsCount} records!`);
            
            // Update download button state to enable downloads
            updateDownloadButtonState();
            
            // Update image box scaling to match current PDF viewer state
            updateImageBoxScaling();
        }

        function updateCreateRecordsButtonState() {
            // Multiple records buttons were removed
            // This function is kept for compatibility but does nothing
        }
        
        // Page navigation variables
        let currentPage = 0;
        let recordsPerPage = 4;
        let totalPages = 1;
        
        function updatePageNavigation() {
            const pageNav = document.getElementById('pageNavigation');
            const pageInfo = document.getElementById('pageInfo');
            const pageRecordsInfo = document.getElementById('pageRecordsInfo');
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                pageNav.style.display = 'none';
                return;
            }
            
            // Calculate records per page based on the box count selection
            // This should be the number of boxes the user wants to show per page
            const boxCountSelect = document.getElementById('boxCountSelect');
            const selectedBoxCount = boxCountSelect ? parseInt(boxCountSelect.value) || 4 : 4;
            
            // Set records per page to the selected box count
            recordsPerPage = selectedBoxCount;
            
            // Ensure recordsPerPage doesn't exceed the total number of CSV records
            if (sessionState.csvRows && sessionState.csvRows.length > 0) {
                recordsPerPage = Math.min(recordsPerPage, sessionState.csvRows.length);
            }
            
            totalPages = Math.ceil(sessionState.csvRows.length / recordsPerPage);
            
            // Update page info
            pageInfo.textContent = `Page ${currentPage + 1} of ${totalPages}`;
            
            // Calculate record range for current page
            const startRecord = currentPage * recordsPerPage;
            const endRecord = Math.min(startRecord + recordsPerPage - 1, sessionState.csvRows.length - 1);
            pageRecordsInfo.textContent = `Showing records ${startRecord + 1}-${endRecord + 1}`;
            
            // Update button states
            prevBtn.disabled = currentPage === 0;
            nextBtn.disabled = currentPage >= totalPages - 1;
            
            // Show navigation
            pageNav.style.display = 'block';
        }
        
        function previousPage() {
            if (currentPage > 0) {
                currentPage--;
                updatePageNavigation();
                updateAllBoxesWithCSVData(); // This already handles both text and image boxes
            }
        }
        
        function nextPage() {
            if (currentPage < totalPages - 1) {
                currentPage++;
                updatePageNavigation();
                updateAllBoxesWithCSVData(); // This already handles both text and image boxes
            }
        }
        
        function updateRecordDisplay() {
            updatePageNavigation();
        }

        // Function to show which record the boxes represent
        function showRecordInfo(selectedBox, correspondingBox = null) {
            console.log('showRecordInfo called with:', selectedBox);
            console.log('CSV rows available:', sessionState.csvRows ? sessionState.csvRows.length : 0);
            
            if (!selectedBox || !sessionState.csvRows) {
                console.log('No selected box or CSV data available');
                return;
            }
            
            // Find the box's index in the main boxes array
            const boxArrayIndex = sessionState.boxes.indexOf(selectedBox);
            console.log('Box array index found:', boxArrayIndex);
            if (boxArrayIndex === -1) {
                console.log('Box not found in sessionState.boxes');
                return;
            }
            
            // Get the record index directly from the box's boxIndex property
            // This is more reliable than calculating from array position
            let recordIndex;
            if (selectedBox.boxIndex !== undefined) {
                // Use the boxIndex property if available
                recordIndex = selectedBox.boxIndex;
                console.log('Using box.boxIndex:', recordIndex);
            } else {
                // Fallback to array-based calculation
                const pageIndex = boxArrayIndex % recordsPerPage;
                recordIndex = currentPage * recordsPerPage + pageIndex;
                console.log('Using array-based calculation - pageIndex:', pageIndex, 'recordIndex:', recordIndex);
            }
            
            // Calculate the actual record number (1-based for display)
            const actualRecordNumber = recordIndex + 1;
            
            if (recordIndex < sessionState.csvRows.length) {
                const record = sessionState.csvRows[recordIndex];
                
                // Update the integrated record info display in the left panel
                const recordInfoDisplay = document.getElementById('recordInfoDisplay');
                const recordInfoText = document.getElementById('recordInfoText');
                
                if (recordInfoDisplay && recordInfoText) {
                    // Show the record info display
                    recordInfoDisplay.style.display = 'block';
                    
                    // Update the main text
                    recordInfoText.textContent = `Record ${actualRecordNumber} of ${sessionState.csvRows.length}`;
                    
                    console.log('Record info shown for box:', selectedBox, 'Box array index:', boxArrayIndex, 'Record index:', recordIndex, 'Record:', actualRecordNumber, 'of', sessionState.csvRows.length);
                }
            } else {
                console.log('Record index out of bounds:', recordIndex, 'CSV rows:', sessionState.csvRows.length);
            }
        }
        
        function generateRecordsPreview() {
            const previewContainer = document.getElementById('previewContainer');
            if (!previewContainer || !sessionState.csvRows || sessionState.csvRows.length === 0) return;
            
            const totalRecords = sessionState.csvRows.length;
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            
            let previewHTML = '';
            
            for (let pageIndex = 0; pageIndex < totalPages; pageIndex++) {
                const startRecord = pageIndex * recordsPerPage;
                const endRecord = Math.min(startRecord + recordsPerPage, totalRecords);
                const recordsOnThisPage = endRecord - startRecord;
                
                previewHTML += `
                    <div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; background: white;">
                        <div style="font-weight: bold; color: #007bff; margin-bottom: 8px;">
                            Page ${pageIndex + 1} (Records ${startRecord + 1}-${endRecord})
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 5px;">
                `;
                
                for (let i = 0; i < recordsOnThisPage; i++) {
                    const recordIndex = startRecord + i;
                    const record = sessionState.csvRows[recordIndex];
                    const recordText = Object.values(record).slice(0, 3).join(' | '); // Show first 3 fields
                    
                    previewHTML += `
                        <div style="padding: 5px; background: #f0f0f0; border-left: 3px solid #007bff; font-size: 11px;">
                            <strong>Record ${recordIndex + 1}:</strong> ${recordText}
                        </div>
                    `;
                }
                
                previewHTML += `
                        </div>
                    </div>
                `;
            }
            
            previewContainer.innerHTML = previewHTML;
        }
        
        // Initialize simple system when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing simple system...');
            updateRecordsInfo();
            
            // Ensure record info display is hidden initially
            const recordInfoDisplay = document.getElementById('recordInfoDisplay');
            if (recordInfoDisplay) {
                recordInfoDisplay.style.display = 'none';
            }
            
            // Initialize apply mode to "Selected Only" by default
            setApplyMode('selected');
            
            // Add event listener for box count changes
            const boxCountSelect = document.getElementById('boxCountSelect');
            if (boxCountSelect) {
                boxCountSelect.addEventListener('change', function() {
                    console.log('Box count changed to:', this.value);
                    // Reset to first page when box count changes
                    currentPage = 0;
                    updatePageNavigation();
                    updateAllBoxesWithCSVData();
                    // Update download button state when record count changes
                    updateDownloadButtonState();
                });
            }
        });


        
        // InDesign-style layout management
        
        function updateTextBoxMappingDisplay() {
            // For InDesign-style data merge: each text box shows current record
            // The records per page feature will duplicate the layout multiple times
            sessionState.boxes.forEach((box) => {
                const select = document.getElementById(`mapping_${box.id}`);
                if (select) {
                    select.value = currentRecord;
                    textBoxMappings[box.id] = currentRecord;
                }
            });
            
            // Update all text boxes with current record data
            updateAllBoxesWithCSVData();
        }
        
        // Initialize font handling
        initializeFontHandling();

        // Layout Editor Variables
        let selectedBox = null;

        // Page size definitions (in points)
        const PAGE_SIZES = {
            'A4': { width: 595, height: 842 },
            'A5': { width: 420, height: 595 },
            'A6': { width: 298, height: 420 }
        };

        // Initialize simple HTML-based editor
        function initEditor() {
            // Create the overlay container for text boxes
            const overlayContainer = document.createElement('div');
            overlayContainer.id = 'overlayContainer';
            overlayContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 10;
            `;
            
            const pdfViewer = document.getElementById('pdfViewer');
            if (pdfViewer) {
                pdfViewer.appendChild(overlayContainer);
                pdfViewer.style.position = 'relative';
            }
        }

        function toggleEditorMode() {
            isEditorMode = !isEditorMode;
            const viewer = document.getElementById('viewer');
            const editorCanvasElement = document.getElementById('editorCanvas');
            const pdfViewer = document.getElementById('pdfViewer');
            
            if (isEditorMode) {
                // Show both PDF and editor canvas
                viewer.style.display = 'block';
                editorCanvasElement.style.display = 'block';
                
                // Disable PDF dragging when in editor mode
                if (pdfViewer) {
                    pdfViewer.style.cursor = 'default';
                }
                
                if (editorCanvas) {
                    editorCanvas.renderAll();
                }
            } else {
                // Hide editor canvas, keep PDF visible
                editorCanvasElement.style.display = 'none';
                viewer.style.display = 'block';
                
                // Re-enable PDF dragging when not in editor mode
                if (pdfViewer) {
                    pdfViewer.style.cursor = 'grab';
                }
            }
        }



        async function addText() {
            // Ensure editor is initialized
            if (!document.getElementById('overlayContainer')) {
                initEditor();
            }
            
            // Get PDF viewer dimensions for centering
            const pdfViewer = document.getElementById('pdfViewer');
            if (!pdfViewer || !sessionState.templatePdf) {
                alert('Please upload a PDF template first');
                return;
            }
            
            // Check if CSV data is available
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }
            
            // Get number of boxes to add from dropdown
            const boxCount = parseInt(document.getElementById('boxCountSelect').value) || 1;
            
            const rect = pdfViewer.getBoundingClientRect();
            const centerX = (rect.width / 2) - 60;
            const centerY = (rect.height / 2) - 20;
            
            // Get available CSV columns
            const csvColumns = sessionState.csvColumns || [];
            if (csvColumns.length === 0) {
                alert('No CSV columns found. Please check your CSV file.');
                return;
            }
            
            // Create field selection modal
            const selectedField = await showFieldSelectionModal(csvColumns, boxCount, 'text');
            if (!selectedField) {
                return; // User cancelled
            }
            
            // Fallback: if no field selected, use the first available CSV column
            const fieldToUse = selectedField || csvColumns[0];
            
            // Add multiple boxes for the same field across different records
            for (let i = 0; i < boxCount; i++) {
                const offsetX = i * 20; // Small horizontal offset for each box
                const offsetY = i * 15; // Small vertical offset for each box
                const boxX = centerX + offsetX;
                const boxY = centerY + offsetY;
                
                // Get data from the corresponding record
                const recordIndex = i % sessionState.csvRows.length; // Cycle through records
                const recordData = sessionState.csvRows[recordIndex];
                const sampleText = recordData ? recordData[selectedField] || `Record ${recordIndex + 1}` : `Record ${recordIndex + 1}`;
            
            // Create text box element
            const textBox = document.createElement('div');
            textBox.className = 'draggable-text-box';
            textBox.id = 'textBox_' + ++boxCounter;
            
            textBox.style.cssText = `
                position: absolute;
                left: ${boxX}px;
                top: ${boxY}px;
                width: 120px;
                height: 40px;
                min-width: 80px;
                min-height: 25px;
                background: transparent;
                border: none;
                padding: 5px;
                cursor: move;
                pointer-events: auto;
                z-index: 20;
                font-family: '${sessionState.defaultFontFamily || 'Arial'}', Arial, sans-serif;
                font-size: 16px;
                color: #000;
                text-align: center;
                user-select: none;
                box-sizing: border-box;
                overflow: hidden;
                box-shadow: none;
                transition: all 0.1s ease;
                display: block;
                line-height: 1.2;
            `;
            textBox.textContent = sampleText;
            textBox.contentEditable = false; // Disable direct editing since we use the panel
            
            // Add to overlay container
            const overlayContainer = document.getElementById('overlayContainer');
            overlayContainer.appendChild(textBox);
            
            // Make it draggable
            makeDraggable(textBox);
            
            // Add to session state
            const boxData = {
                id: boxCounter,
                boxId: boxCounter, // Add boxId for consistency with delete function
                element: textBox,
                type: 'text',
                boxType: 'text',
                fieldKey: fieldToUse,
                staticText: sampleText,
                boxIndex: recordIndex, // Track which record this box represents
                bold: false,
                italic: false,
                underline: false,
                fontSize: 16,
                fontFamily: sessionState.defaultFontFamily || 'Arial',
                color: '#000000',
                textAlign: 'center',
                x: boxX,
                y: boxY,
                width: 120,
                height: 40
            };
            
            // Add click handler for selection
            textBox.addEventListener('click', function(e) {
                e.stopPropagation();
                console.log('Text box clicked, selecting box:', boxData);
                
                // Remove selection from all boxes
                document.querySelectorAll('.draggable-text-box, .draggable-image-box').forEach(box => {
                    box.style.border = 'none';
                    box.classList.remove('selected');
                });
                
                // Select this box
                textBox.style.border = 'none';
                textBox.classList.add('selected');
                sessionState.selectedBox = boxData;
                console.log('Selected box set to:', sessionState.selectedBox);
                updateBoxEditor();
                updateBoxEditorValues(boxData);
                
                // Show record info for the selected box
                showRecordInfo(boxData);
            });
            
            sessionState.boxes.push(boxData);
            sessionState.selectedBox = boxData;
            currentBoxId = boxCounter;
            
            // Update box editor
            updateBoxEditor();
            updateBoxEditorValues(boxData);
            
            // Update download button state
            updateDownloadButtonState();
            
            // Update text box scaling to match current PDF viewer state
            updateTextBoxScaling();
            
            // Select the text box immediately for editing
            textBox.focus();
            // Remove the problematic select() call - text boxes don't have select() method
            
            // Update text size to fit the initial box dimensions
            updateTextSize(textBox);
        }
        }

        async function addImagePlaceholder() {
            console.log('addImagePlaceholder called');
            
            // Don't toggle editor mode for image boxes - they use DOM elements, not canvas

            // Check if CSV data is available
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }

            // Get number of boxes to add from dropdown
            const boxCount = parseInt(document.getElementById('boxCountSelect').value) || 1;
            
            // Get available CSV columns
            const csvColumns = sessionState.csvColumns || [];
            if (csvColumns.length === 0) {
                alert('No CSV columns found. Please check your CSV file.');
                return;
            }
            
            // Create field selection modal
            const selectedField = await showFieldSelectionModal(csvColumns, boxCount, 'image');
            if (!selectedField) {
                return; // User cancelled
            }
            
            // Fallback: if no field selected, use the first available CSV column
            const fieldToUse = selectedField || csvColumns[0];
            
            // Add multiple image boxes for the same field across different records
            for (let i = 0; i < boxCount; i++) {
                const offsetX = i * 20; // Small horizontal offset for each box
                const offsetY = i * 15; // Small vertical offset for each box
                const boxX = 50 + offsetX;
                const boxY = 50 + offsetY;
                
                // Get data from the corresponding record
                const recordIndex = i % sessionState.csvRows.length; // Cycle through records
                const recordData = sessionState.csvRows[recordIndex];
                const sampleImageUrl = recordData ? recordData[selectedField] || '' : '';
                
                // Create a DOM-based image box (similar to MERGE-ONLINE approach)
                const imageBox = document.createElement('div');
            imageBox.className = 'draggable-image-box';
            
            imageBox.style.cssText = `
                position: absolute;
                left: ${boxX}px;
                top: ${boxY}px;
                width: 100px;
                height: 100px;
                min-width: 40px;
                min-height: 30px;
                background: transparent;
                border: 2px dashed #007bff;
                cursor: move;
                pointer-events: auto;
                z-index: 10;
                overflow: hidden;
                box-sizing: border-box;
                transition: all 0.1s ease;
                transform-origin: top left;
            `;

            // Add custom properties
            imageBox.boxId = ++boxCounter;
            imageBox.boxType = 'image';
            imageBox.fieldKey = selectedField;
            imageBox.imageSource = 'csv';
            imageBox.imageUrl = sampleImageUrl;

            // Load image if URL is available
            if (sampleImageUrl && sampleImageUrl.trim() !== '') {
                loadImageFromUrl(sampleImageUrl, imageBox);
            }

            // Add click handler for selection
            imageBox.addEventListener('click', function(e) {
                e.stopPropagation();
                // Remove selected class from all boxes
                document.querySelectorAll('.draggable-image-box, .draggable-text-box').forEach(box => {
                    box.classList.remove('selected');
                });
                // Add selected class to this box
                imageBox.classList.add('selected');
                
                // Update session state
                sessionState.selectedBox = imageBox;
                currentBoxId = imageBox.boxId;
                
                // Update box editor
                updateBoxEditor();
                updateBoxEditorValues(imageBox);
                
                // Find the box data object and show record info
                const boxData = sessionState.boxes.find(b => b.element === imageBox);
                if (boxData) {
                    showRecordInfo(boxData);
                }
            });

            // Add to overlay container (same as text boxes)
            const overlayContainer = document.getElementById('overlayContainer');
            if (!overlayContainer) {
                initEditor();
            }
            overlayContainer.appendChild(imageBox);

            // Add to session state (same structure as text boxes)
            const boxData = {
                id: imageBox.boxId,
                element: imageBox,
                type: 'image',
                boxType: 'image',
                fieldKey: fieldToUse,
                imageSource: 'csv',
                imageUrl: sampleImageUrl,
                boxIndex: recordIndex, // Track which record this box represents
                x: boxX,
                y: boxY,
                width: 100,
                height: 100
            };
            
            sessionState.boxes.push(boxData);
            sessionState.selectedBox = boxData;
            currentBoxId = imageBox.boxId;
            
            // Update box editor
            updateBoxEditor();
            updateBoxEditorValues(boxData);

            // Enable drag and resize for this box
            enableDragResize(imageBox);
            
            // Add resize handles for visual feedback
            addResizeHandles(imageBox);

            updateEditorStatus('Image box created - drag it to position and edit properties');
            
            // Update download button state to enable downloads
            updateDownloadButtonState();
            
            // Update image box scaling to match current PDF viewer state
            updateImageBoxScaling();
            }
        }

        // Function to load image from URL - matching MERGE-ONLINE behavior
        function loadImageFromUrl(imageUrl, imageBox) {
            if (!imageUrl || imageUrl.trim() === '') {
                console.log('No image URL provided');
                return;
            }

            console.log('Loading image from URL:', imageUrl);
            
            // Create image element
            const img = document.createElement('img');
            img.crossOrigin = 'anonymous';
            
            // Clear existing content
            imageBox.innerHTML = '';
            
            // Add image only (no delete button for image boxes)
            imageBox.appendChild(img);
            
            // Load image with proper styling
            img.onload = function() {
                console.log('Image loaded successfully');
                
                // Apply MERGE-ONLINE style behavior
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                img.style.objectPosition = 'center';
                img.style.display = 'block';
                img.style.aspectRatio = 'auto';
                img.style.imageRendering = 'auto';
                
                // Keep the box styling (don't remove border/background)
                imageBox.style.border = '2px dashed #007bff';
                imageBox.style.background = 'rgba(255,255,255,0.2)';
            };
            
            img.onerror = function() {
                console.error('Failed to load image:', imageUrl);
                imageBox.textContent = 'No Image';
                imageBox.style.color = '#666';
                imageBox.style.fontWeight = 'normal';
                imageBox.style.fontSize = '12px';
                imageBox.style.border = '2px dashed #007bff';
                imageBox.style.background = 'rgba(255,255,255,0.2)';
            };
            
            // Set image source using proxy
            img.src = `proxy_image.php?url=${encodeURIComponent(imageUrl)}`;
        }

        // Function to enable drag and resize for DOM elements (similar to MERGE-ONLINE)
        function enableDragResize(element) {
            // Make sure Interact.js is available
            if (typeof interact === 'undefined') {
                console.error('Interact.js not loaded');
                return;
            }

            // Enable dragging
            interact(element).draggable({
                listeners: {
                    start: function(event) {
                        event.target.classList.add('dragging');
                    },
                    move: function(event) {
                        const target = event.target;
                        const left = parseFloat(target.style.left) + event.dx;
                        const top = parseFloat(target.style.top) + event.dy;
                        
                        if (snapToGridEnabled) {
                            // Apply snap-to-grid when enabled
                            const snappedPosition = snapToGrid(left, top, target);
                            target.style.left = snappedPosition.x + 'px';
                            target.style.top = snappedPosition.y + 'px';
                        } else {
                            // Free movement when snap-to-grid is disabled
                            target.style.left = left + 'px';
                            target.style.top = top + 'px';
                        }
                    },
                    end: function(event) {
                        event.target.classList.remove('dragging');
                        clearSnapGuides();
                    }
                }
            });

            // Enable resizing
            interact(element).resizable({
                edges: { left: true, right: true, top: true, bottom: true },
                listeners: {
                    move: function(event) {
                        const target = event.target;
                        let width = parseFloat(target.style.width);
                        let height = parseFloat(target.style.height);
                        let left = parseFloat(target.style.left);
                        let top = parseFloat(target.style.top);

                        // Update width and height
                        width += event.deltaRect.width;
                        height += event.deltaRect.height;
                        
                        // Update position for left and top edges
                        left += event.deltaRect.left;
                        top += event.deltaRect.top;

                        if (snapToGridEnabled) {
                            // Apply snap-to-grid when enabled
                            const snappedPosition = snapToGrid(left, top, target);
                            target.style.width = width + 'px';
                            target.style.height = height + 'px';
                            target.style.left = snappedPosition.x + 'px';
                            target.style.top = snappedPosition.y + 'px';
                        } else {
                            // Apply changes with free positioning
                            target.style.width = width + 'px';
                            target.style.height = height + 'px';
                            target.style.left = left + 'px';
                            target.style.top = top + 'px';
                        }
                    
                    // Ensure images maintain aspect ratio after resize
                    if (target.classList.contains('draggable-image-box')) {
                        const img = target.querySelector('img');
                        if (img) {
                            img.style.objectFit = 'contain';
                            img.style.objectPosition = 'center';
                            img.style.aspectRatio = 'auto';
                            img.style.imageRendering = 'auto';
                        }
                    }
                    }
                }
            });
        }

        // Function to load static image
        function loadStaticImage(box, imageUrl) {
            console.log('loadStaticImage called with:', box, imageUrl);
            if (!imageUrl) return;
            
            // Use proxy to handle CORS
            const proxiedUrl = 'proxy_image.php?url=' + encodeURIComponent(imageUrl);
            console.log('Proxied URL:', proxiedUrl);
            
            // Create image element
            const img = document.createElement('img');
            img.crossOrigin = 'anonymous'; // Add CORS attribute
            img.src = proxiedUrl;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            img.style.objectPosition = 'center';
            
            // Add error handling
            img.onerror = function() {
                console.error('Failed to load image:', imageUrl);
                console.error('Error details:', this.src);
                box.innerHTML = '<div style="color: red; text-align: center; padding: 10px; font-size: 12px;">Failed to load image<br>' + imageUrl + '</div>';
            };
            
            img.onload = function() {
                console.log('Image loaded successfully:', imageUrl);
            };
            
            // Clear existing content and add image
            box.innerHTML = '';
            box.appendChild(img);
            
            // Update box properties
            box.imageUrl = imageUrl;
        }

        // Function to update image box with CSV data
        function updateImageBoxWithCSVData(box) {
            console.log('updateImageBoxWithCSVData called with:', box);
            if (box.boxType !== 'image' || !box.csvColumn) {
                console.log('Box is not image type or no CSV column selected');
                return;
            }
            
            // Get current CSV row data
            const currentRow = sessionState.csvRows && sessionState.csvRows[currentPage * recordsPerPage + (box.boxIndex || 0)];
            if (!currentRow) {
                console.log('No current row data available');
                return;
            }
            
            const imageUrl = currentRow[box.csvColumn];
            console.log('Image URL from CSV:', imageUrl);
            if (!imageUrl) {
                console.log('No image URL found in CSV column');
                return;
            }
            
            // Use proxy to handle CORS
            const proxiedUrl = 'proxy_image.php?url=' + encodeURIComponent(imageUrl);
            console.log('Proxied URL for CSV image:', proxiedUrl);
            
            // Create image element
            const img = document.createElement('img');
            img.crossOrigin = 'anonymous'; // Add CORS attribute
            img.src = proxiedUrl;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            img.style.objectPosition = 'center';
            
            // Add error handling
            img.onerror = function() {
                console.error('Failed to load CSV image:', imageUrl);
                console.error('Error details:', this.src);
                box.innerHTML = '<div style="color: red; text-align: center; padding: 10px; font-size: 12px;">Failed to load CSV image<br>' + imageUrl + '</div>';
            };
            
            img.onload = function() {
                console.log('CSV image loaded successfully:', imageUrl);
            };
            
            // Clear existing content and add image
            box.innerHTML = '';
            box.appendChild(img);
            
            // Update box properties
            box.imageUrl = imageUrl;
        }

        function duplicateObject() {
            if (!selectedEditorObject || !editorCanvas) return;

            const clone = fabric.util.object.clone(selectedEditorObject);
            clone.set({
                left: selectedEditorObject.left + 20,
                top: selectedEditorObject.top + 20
            });

            editorCanvas.add(clone);
            editorCanvas.setActiveObject(clone);
            updateEditorStatus('Object duplicated');
        }

        function toggleLock() {
            if (!selectedEditorObject) return;

            selectedEditorObject.selectable = !selectedEditorObject.selectable;
            selectedEditorObject.evented = !selectedEditorObject.evented;
            
            const lockBtn = document.getElementById('lockBtn');
            if (selectedEditorObject.selectable) {
                lockBtn.textContent = 'Lock';
                lockBtn.className = 'editor-btn editor-btn-warning';
            } else {
                lockBtn.textContent = 'Unlock';
                lockBtn.className = 'editor-btn editor-btn-success';
            }

            updateEditorStatus(selectedEditorObject.selectable ? 'Object unlocked' : 'Object locked');
        }

        function deleteObject() {
            if (!selectedEditorObject || !editorCanvas) return;

            editorCanvas.remove(selectedEditorObject);
            editorCanvas.discardActiveObject();
            updateEditorStatus('Object deleted');
        }

        function clearCanvas() {
            if (!editorCanvas) return;

            if (confirm('Are you sure you want to clear all objects?')) {
                editorCanvas.clear();
                updateEditorStatus('Canvas cleared');
            }
        }

        function onEditorObjectSelected(e) {
            selectedEditorObject = e.target;
            updateEditorSidebar();
            updateEditorButtonStates(true);
            updateEditorStatus('Object selected');
        }

        function onEditorObjectDeselected() {
            selectedEditorObject = null;
            document.getElementById('editorSidebar').classList.remove('active');
            updateEditorButtonStates(false);
            updateEditorStatus('No object selected');
        }

        function onEditorObjectModified(e) {
            updateEditorSidebar();
            updateEditorStatus('Object modified');
        }

        function onEditorObjectMoving(e) {
            if (gridSize > 0) {
                const obj = e.target;
                obj.set({
                    left: Math.round(obj.left / gridSize) * gridSize,
                    top: Math.round(obj.top / gridSize) * gridSize
                });
            }
        }

        function onEditorObjectScaling(e) {
            if (gridSize > 0) {
                const obj = e.target;
                obj.set({
                    width: Math.round(obj.width / gridSize) * gridSize,
                    height: Math.round(obj.height / gridSize) * gridSize
                });
            }
        }

        function updateEditorSidebar() {
            if (!selectedEditorObject) return;

            document.getElementById('editorSidebar').classList.add('active');

            // Get object metadata
            const meta = selectedEditorObject.meta || {};

            // Update form fields
            document.getElementById('bindField').value = meta.bind || '';
            document.getElementById('staticContent').value = meta.static || '';
            document.getElementById('posX').value = Math.round(selectedEditorObject.left);
            document.getElementById('posY').value = Math.round(selectedEditorObject.top);
            document.getElementById('width').value = Math.round(selectedEditorObject.width || selectedEditorObject.scaleX * 100);
            document.getElementById('height').value = Math.round(selectedEditorObject.height || selectedEditorObject.scaleY * 100);

            // Add event listeners for form changes
            document.getElementById('bindField').onchange = updateEditorObjectMeta;
            document.getElementById('staticContent').oninput = updateEditorObjectMeta;
            document.getElementById('posX').onchange = updateEditorObjectPosition;
            document.getElementById('posY').onchange = updateEditorObjectPosition;
            document.getElementById('width').onchange = updateEditorObjectSize;
            document.getElementById('height').onchange = updateEditorObjectSize;
        }

        function updateEditorObjectMeta() {
            if (!selectedEditorObject) return;

            selectedEditorObject.meta = {
                bind: document.getElementById('bindField').value,
                static: document.getElementById('staticContent').value
            };

            // Update text content if it's a text object
            if (selectedEditorObject.type === 'text' && document.getElementById('staticContent').value) {
                selectedEditorObject.set('text', document.getElementById('staticContent').value);
            }

            editorCanvas.renderAll();
        }

        function updateEditorObjectPosition() {
            if (!selectedEditorObject) return;

            selectedEditorObject.set({
                left: parseInt(document.getElementById('posX').value),
                top: parseInt(document.getElementById('posY').value)
            });

            editorCanvas.renderAll();
        }

        function updateEditorObjectSize() {
            if (!selectedEditorObject) return;

            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);

            if (selectedEditorObject.type === 'text') {
                selectedEditorObject.set('fontSize', Math.min(width, height) / 2);
            } else {
                selectedEditorObject.set({
                    width: width,
                    height: height
                });
            }

            editorCanvas.renderAll();
        }

        function updateEditorButtonStates(enabled) {
            document.getElementById('duplicateBtn').disabled = !enabled;
            document.getElementById('lockBtn').disabled = !enabled;
            document.getElementById('deleteBtn').disabled = !enabled;
        }

        // Enhanced Box Management Functions
        function updateBoxEditor() {
            const deleteBoxBtn = document.getElementById('deleteBoxBtn');
            console.log('updateBoxEditor called, selectedBox:', sessionState.selectedBox);
            console.log('deleteBoxBtn found:', !!deleteBoxBtn);
            
            if (sessionState.selectedBox) {
                // Enable delete button when a box is selected
                if (deleteBoxBtn) {
                    deleteBoxBtn.disabled = false;
                    console.log('Delete button enabled');
                }
            } else {
                // Disable delete button when no box is selected
                if (deleteBoxBtn) {
                    deleteBoxBtn.disabled = true;
                    console.log('Delete button disabled');
                }
                
                // Hide record info when no box is selected
                const recordInfoDisplay = document.getElementById('recordInfoDisplay');
                if (recordInfoDisplay) {
                    recordInfoDisplay.style.display = 'none';
                }
            }
            
            // Update the create records button state
            updateCreateRecordsButtonState();
        }

        function updateBoxEditorValues(box) {
            if (!box) return;

            // Update CSV column dropdown
            const columnSelect = document.getElementById('boxColumnSelect');
            if (columnSelect) {
            columnSelect.innerHTML = '<option value="">Select CSV column...</option>';
                
                console.log('Updating CSV column dropdown. csvData:', csvData);
            
            if (csvData && csvData.length > 0) {
                const columns = Object.keys(csvData[0]);
                    console.log('CSV columns found:', columns);
                columns.forEach(column => {
                    const option = document.createElement('option');
                    option.value = column;
                    option.textContent = column;
                    option.selected = column === box.csvColumn;
                    columnSelect.appendChild(option);
                });
                } else {
                    console.log('No CSV data available for column dropdown');
                }
            }

            // Add event listeners
            addBoxEditorEventListeners(box);
        }

        function addBoxEditorEventListeners(box) {
            // CSV Column change
            const columnSelect = document.getElementById('boxColumnSelect');
            if (columnSelect) {
                columnSelect.onchange = function() {
                box.csvColumn = this.value;
                    if (box.boxType === 'text') {
                updateTextBoxContent(box);
                    } else if (box.boxType === 'image' && box.imageSource === 'csv') {
                        updateImageBoxWithCSVData(box);
                    }
                updateEditorStatus(`Box bound to CSV column: ${this.value || 'None'}`);
                updateCreateRecordsButtonState();
                };
            }
        }

        function duplicateSelectedBox() {
            if (!sessionState.selectedBox) return;

            const original = sessionState.selectedBox;
            
            if (original.style) {
                // DOM element - create a new DOM element
                const clone = original.cloneNode(true);
                clone.boxId = ++boxCounter;
                clone.boxType = original.boxType;
                clone.csvColumn = original.csvColumn;
                clone.imageSource = original.imageSource;
                clone.imageUrl = original.imageUrl;
                
                // Offset the clone
                const originalLeft = parseFloat(original.style.left) || 0;
                const originalTop = parseFloat(original.style.top) || 0;
                clone.style.left = (originalLeft + 20) + 'px';
                clone.style.top = (originalTop + 20) + 'px';
                

                
                // Add click handler for selection
                clone.addEventListener('click', function(e) {
                    e.stopPropagation();
                    // Remove selection from all boxes
                    document.querySelectorAll('.draggable-image-box, .draggable-text-box').forEach(box => {
                        box.classList.remove('selected');
                    });
                    clone.classList.add('selected');
                    sessionState.selectedBox = clone;
                    currentBoxId = clone.boxId;
                    updateBoxEditor();
                    updateBoxEditorValues(clone);
                });
                
                // Add to PDF viewer and enable drag/resize
                const pdfViewer = document.getElementById('pdfViewer');
                pdfViewer.appendChild(clone);
                enableDragResize(clone);
                
                sessionState.boxes.push(clone);
                sessionState.selectedBox = clone;
                currentBoxId = clone.boxId;
                updateBoxEditorValues(clone);
            } else {
                // Fabric.js object
                if (!editorCanvas) return;
            const clone = fabric.util.object.clone(original);
            
            // Offset the clone
            clone.set({
                left: original.left + 20,
                top: original.top + 20,
                boxId: ++boxCounter
            });

            // Copy custom properties
            clone.boxType = original.boxType;
            clone.csvColumn = original.csvColumn;
            clone.staticText = original.staticText;
            clone.bold = original.bold;
            clone.italic = original.italic;
            clone.underline = original.underline;
            clone.imageSource = original.imageSource;
            clone.imageUrl = original.imageUrl;

            editorCanvas.add(clone);
            sessionState.boxes.push(clone);
            
            // Select the new clone
            sessionState.selectedBox = clone;
            currentBoxId = clone.boxId;
            updateBoxEditorValues(clone);
            }
            
            updateEditorStatus('Box duplicated');
        }

        function deleteSelectedBox() {
            if (!sessionState.selectedBox) return;

            // Save undo state before deleting (placeholder)
            // saveUndoState('Delete Box');

            const selectedItem = sessionState.selectedBox;
            
            console.log('=== DELETE DEBUG ===');
            console.log('Selected item:', selectedItem);
            console.log('Selected item type:', typeof selectedItem);
            console.log('Selected item properties:', Object.keys(selectedItem));
            console.log('sessionState.boxes:', sessionState.boxes);
            console.log('Boxes length:', sessionState.boxes.length);
            
            // Determine if selectedItem is a box object or DOM element
            let boxObject = null;
            let domElement = null;
            
            if (selectedItem.element && selectedItem.boxId) {
                // It's a box object with an element property
                boxObject = selectedItem;
                domElement = selectedItem.element;
                console.log('Found box object with element property');
            } else if (selectedItem.classList && (selectedItem.classList.contains('draggable-text-box') || selectedItem.classList.contains('draggable-image-box'))) {
                // It's a DOM element, find the corresponding box object
                domElement = selectedItem;
                boxObject = sessionState.boxes.find(box => box.element === selectedItem);
                console.log('Found DOM element, looking for box object:', boxObject);
            } else {
                // It's a box object stored directly
                boxObject = selectedItem;
                domElement = selectedItem.element || null;
                console.log('Found box object stored directly');
            }
            
            if (boxObject) {
                console.log('Box object found, removing...');
                
                // Remove from DOM if we have a DOM element
                if (domElement && domElement.remove) {
                    domElement.remove();
                    console.log('DOM element removed');
                } else {
                    console.log('No DOM element to remove or remove method not available');
                }
                
                // Remove from session state using ID (like MERGE-ONLINE)
                if (boxObject.boxId) {
                    sessionState.boxes = sessionState.boxes.filter(box => box.boxId !== boxObject.boxId);
                } else if (boxObject.id) {
                    sessionState.boxes = sessionState.boxes.filter(box => box.id !== boxObject.id);
                } else {
                    // Remove by direct reference if no ID
                    sessionState.boxes = sessionState.boxes.filter(box => box !== boxObject);
                }
                console.log('Box removed from sessionState.boxes');
            }
            
            // Clear selection and remove selected class from all boxes
            document.querySelectorAll('.draggable-text-box.selected, .draggable-image-box.selected').forEach(box => {
                box.classList.remove('selected');
            });
            sessionState.selectedBox = null;
            
            // Hide box editor
            updateBoxEditor();
            
            updateEditorStatus('Box deleted');
            
            // Update download button state after deletion
            updateDownloadButtonState();
            
            // Update box scaling after deletion
            updateImageBoxScaling();
            updateTextBoxScaling();
        }

        // Enhanced delete function that works with both DOM elements and box objects
        function deleteBox(box) {
            if (!box) return;
            
            // If it's a DOM element, find the corresponding box object
            let boxElement = box;
            let boxObject = null;
            
            if (box.element) {
                // It's a box object, get the element
                boxElement = box.element;
                boxObject = box;
            } else if (box.classList && box.classList.contains('draggable-text-box') || box.classList.contains('draggable-image-box')) {
                // It's a DOM element, find the box object
                boxObject = sessionState.boxes.find(b => b.element === box);
            }
            
            if (!boxElement || !boxObject) return;
            
            // Remove from DOM
            if (boxElement.remove) {
                boxElement.remove();
            }
            
            // Remove from session state
            sessionState.boxes = sessionState.boxes.filter(b => b.boxId !== boxObject.boxId);
            
            // Clear selection if this was the selected box
            if (sessionState.selectedBox && sessionState.selectedBox.boxId === boxObject.boxId) {
                sessionState.selectedBox = null;
                updateBoxEditor();
            }
            
            updateEditorStatus('Box deleted');
            updateDownloadButtonState();
            updateImageBoxScaling();
            updateTextBoxScaling();
        }



        // Keyboard shortcuts for box management
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Delete key to delete selected box
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (sessionState.selectedBox) {
                        e.preventDefault();
                        deleteSelectedBox();
                    }
                }
                
                // Escape key to deselect
                if (e.key === 'Escape') {
                    if (sessionState.selectedBox) {
                        e.preventDefault();
                        document.querySelectorAll('.draggable-text-box.selected, .draggable-image-box.selected').forEach(box => {
                            box.classList.remove('selected');
                        });
                        sessionState.selectedBox = null;
                        updateBoxEditor();
                    }
                }
            });

            // Right-click context menu for boxes
            document.addEventListener('contextmenu', function(e) {
                const target = e.target;
                if (target.classList.contains('draggable-text-box') || target.classList.contains('draggable-image-box')) {
                    e.preventDefault();
                    
                    // Select the box if not already selected
                    if (!target.classList.contains('selected')) {
                        document.querySelectorAll('.draggable-text-box, .draggable-image-box').forEach(box => {
                            box.classList.remove('selected');
                        });
                        target.classList.add('selected');
                        
                        // Update session state
                        const boxObject = sessionState.boxes.find(b => b.element === target);
                        if (boxObject) {
                            sessionState.selectedBox = boxObject;
                            updateBoxEditor();
                            updateBoxEditorValues(boxObject);
                        }
                    }
                    
                    // Show context menu
                    showBoxContextMenu(e.clientX, e.clientY, target);
                }
            });
        }

        // Context menu for boxes
        function showBoxContextMenu(x, y, boxElement) {
            // Remove existing context menu
            const existingMenu = document.getElementById('boxContextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // Create context menu
            const contextMenu = document.createElement('div');
            contextMenu.id = 'boxContextMenu';
            contextMenu.style.cssText = `
                position: fixed;
                top: ${y}px;
                left: ${x}px;
                background: white;
                border: 1px solid #ccc;
                border-radius: 4px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                z-index: 1000;
                min-width: 150px;
                font-size: 14px;
            `;
            
            // Delete option
            const deleteOption = document.createElement('div');
            deleteOption.style.cssText = `
                padding: 8px 12px;
                cursor: pointer;
                border-bottom: 1px solid #eee;
                display: flex;
                align-items: center;
                gap: 8px;
            `;
            deleteOption.innerHTML = '🗑️ Delete Box';
            deleteOption.addEventListener('click', function() {
                deleteBox(boxElement);
                contextMenu.remove();
            });
            deleteOption.addEventListener('mouseenter', function() {
                this.style.background = '#f8f9fa';
            });
            deleteOption.addEventListener('mouseleave', function() {
                this.style.background = 'white';
            });
            
            // Duplicate option
            const duplicateOption = document.createElement('div');
            duplicateOption.style.cssText = `
                padding: 8px 12px;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 8px;
            `;
            duplicateOption.innerHTML = '📋 Duplicate Box';
            duplicateOption.addEventListener('click', function() {
                duplicateSelectedBox();
                contextMenu.remove();
            });
            duplicateOption.addEventListener('mouseenter', function() {
                this.style.background = '#f8f9fa';
            });
            duplicateOption.addEventListener('mouseleave', function() {
                this.style.background = 'white';
            });
            
            contextMenu.appendChild(deleteOption);
            contextMenu.appendChild(duplicateOption);
            document.body.appendChild(contextMenu);
            
            // Close context menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu() {
                    contextMenu.remove();
                    document.removeEventListener('click', closeMenu);
                });
            }, 100);
        }

        // Simple drag functionality for text boxes
        function makeDraggable(element) {
            let isDragging = false;
            let isResizing = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;
            let initialWidth;
            let initialHeight;
            let resizeHandle = '';

            // Add resize handles
            addResizeHandles(element);

            // Use mousedown on the element itself
            element.addEventListener('mousedown', dragStart);
            
            // Use document-level events for better drag handling
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            function dragStart(e) {
                // Prevent event from bubbling to PDF viewer
                e.stopPropagation();
                
                // Check if clicking on resize handle
                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true;
                    isDragging = false;
                    resizeHandle = e.target.dataset.handle;
                    initialWidth = element.offsetWidth;
                    initialHeight = element.offsetHeight;
                    initialX = e.clientX;
                    initialY = e.clientY;
                    element.style.cursor = 'nwse-resize';
                    element.classList.add('resizing');
                    return;
                }

                // Normal dragging
                if (e.target === element) {
                    isDragging = true;
                    isResizing = false;
                    
                    // Get current position (accounting for any existing transform)
                    const currentLeft = parseInt(element.style.left) || 0;
                    const currentTop = parseInt(element.style.top) || 0;
                    
                    // Reset any existing transform
                    element.style.transform = 'translate(0px, 0px)';
                    
                    // Initialize drag tracking
                    initialX = e.clientX - currentLeft;
                    initialY = e.clientY - currentTop;
                    xOffset = currentLeft;
                    yOffset = currentTop;
                    
                    element.style.cursor = 'grabbing';
                    element.style.zIndex = '30';
                }
            }

            function drag(e) {
                if (isResizing) {
                    e.preventDefault();
                    e.stopPropagation();
                    const deltaX = e.clientX - initialX;
                    const deltaY = e.clientY - initialY;
                    
                    // Get the PDF viewer container for boundary constraints
                    const pdfViewer = document.getElementById('pdfViewer');
                    const viewerRect = pdfViewer.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();
                    
                    // Calculate new dimensions and positions with constraints
                    let newWidth = initialWidth;
                    let newHeight = initialHeight;
                    let newLeft = parseInt(element.style.left) || 0;
                    let newTop = parseInt(element.style.top) || 0;
                    
                    // Handle right edge resize
                    if (resizeHandle.includes('e')) {
                        newWidth = Math.max(20, initialWidth + deltaX);
                        // Constrain to viewer width
                        const maxWidth = viewerRect.width - newLeft;
                        newWidth = Math.min(newWidth, maxWidth);
                    }
                    
                    // Handle left edge resize
                    if (resizeHandle.includes('w')) {
                        const proposedWidth = Math.max(20, initialWidth - deltaX);
                        const proposedLeft = newLeft + (initialWidth - proposedWidth);
                        
                        // Constrain to viewer boundaries
                        if (proposedLeft >= 0 && proposedLeft + proposedWidth <= viewerRect.width) {
                            newWidth = proposedWidth;
                            newLeft = proposedLeft;
                        }
                    }
                    
                    // Handle bottom edge resize
                    if (resizeHandle.includes('s')) {
                        newHeight = Math.max(10, initialHeight + deltaY);
                        // Constrain to viewer height
                        const maxHeight = viewerRect.height - newTop;
                        newHeight = Math.min(newHeight, maxHeight);
                    }
                    
                    // Handle top edge resize
                    if (resizeHandle.includes('n')) {
                        const proposedHeight = Math.max(10, initialHeight - deltaY);
                        const proposedTop = newTop + (initialHeight - proposedHeight);
                        
                        // Constrain to viewer boundaries
                        if (proposedTop >= 0 && proposedTop + proposedHeight <= viewerRect.height) {
                            newHeight = proposedHeight;
                            newTop = proposedTop;
                        }
                    }
                    
                    // Apply the constrained values
                    element.style.width = newWidth + 'px';
                    element.style.height = newHeight + 'px';
                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                    
                    // Update font size based on box size
                    updateTextSize(element);
                } else if (isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;

                    // Get the PDF viewer container for boundary constraints
                    const pdfViewer = document.getElementById('pdfViewer');
                    const viewerRect = pdfViewer.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();
                    
                    // Constrain dragging within viewer boundaries
                    const maxX = viewerRect.width - elementRect.width;
                    const maxY = viewerRect.height - elementRect.height;
                    
                    currentX = Math.max(0, Math.min(currentX, maxX));
                    currentY = Math.max(0, Math.min(currentY, maxY));
                    
                    xOffset = currentX;
                    yOffset = currentY;

                    // Apply constrained position directly
                    element.style.left = currentX + 'px';
                    element.style.top = currentY + 'px';
                }
            }

            function dragEnd(e) {
                // Prevent event from bubbling to PDF viewer
                e.stopPropagation();
                
                if (isResizing) {
                    isResizing = false;
                    element.style.cursor = 'move';
                    element.style.zIndex = '20';
                    resizeHandle = '';
                    element.classList.remove('resizing');
                    
                    // Update the box data in session state
                    if (sessionState.selectedBox && sessionState.selectedBox.element === element) {
                        sessionState.selectedBox.width = parseInt(element.style.width);
                        sessionState.selectedBox.height = parseInt(element.style.height);
                        sessionState.selectedBox.x = parseInt(element.style.left);
                        sessionState.selectedBox.y = parseInt(element.style.top);
                    }
                    
                } else if (isDragging) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    element.style.cursor = 'move';
                    element.style.zIndex = '20';
                    clearSnapGuides();
                    
                    // Update the box data in session state
                    if (sessionState.selectedBox && sessionState.selectedBox.element === element) {
                        sessionState.selectedBox.x = parseInt(element.style.left);
                        sessionState.selectedBox.y = parseInt(element.style.top);
                    }
                }
            }
        }

        function addResizeHandles(element) {
            const handles = [
                { position: 'nw', cursor: 'nw-resize' },
                { position: 'n', cursor: 'n-resize' },
                { position: 'ne', cursor: 'ne-resize' },
                { position: 'e', cursor: 'e-resize' },
                { position: 'se', cursor: 'se-resize' },
                { position: 's', cursor: 's-resize' },
                { position: 'sw', cursor: 'sw-resize' },
                { position: 'w', cursor: 'w-resize' }
            ];

            handles.forEach(handle => {
                const handleElement = document.createElement('div');
                handleElement.className = 'resize-handle';
                handleElement.dataset.handle = handle.position;
                handleElement.style.cssText = `
                    position: absolute;
                    width: 12px;
                    height: 12px;
                    background: #ff6b35;
                    border: 2px solid white;
                    border-radius: 2px;
                    cursor: ${handle.cursor};
                    pointer-events: auto;
                    z-index: 25;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                `;

                // Position the handle
                switch (handle.position) {
                    case 'nw': handleElement.style.top = '-6px'; handleElement.style.left = '-6px'; break;
                    case 'n': handleElement.style.top = '-6px'; handleElement.style.left = '50%'; handleElement.style.transform = 'translateX(-50%)'; break;
                    case 'ne': handleElement.style.top = '-6px'; handleElement.style.right = '-6px'; break;
                    case 'e': handleElement.style.top = '50%'; handleElement.style.right = '-6px'; handleElement.style.transform = 'translateY(-50%)'; break;
                    case 'se': handleElement.style.bottom = '-6px'; handleElement.style.right = '-6px'; break;
                    case 's': handleElement.style.bottom = '-6px'; handleElement.style.left = '50%'; handleElement.style.transform = 'translateX(-50%)'; break;
                    case 'sw': handleElement.style.bottom = '-6px'; handleElement.style.left = '-6px'; break;
                    case 'w': handleElement.style.top = '50%'; handleElement.style.left = '-6px'; handleElement.style.transform = 'translateY(-50%)'; break;
                }

                element.appendChild(handleElement);
            });
        }

        // Snap-to-Grid System
        const GRID_SIZE = 50; // Grid size in pixels (increased from 20 for looser grid)
        const SNAP_THRESHOLD = 25; // Distance to snap in pixels (increased from 10 for gentler snapping)
        let snapToGridEnabled = false; // Toggle for snap-to-grid feature - DISABLED for free movement

        function toggleSnapToGrid() {
            snapToGridEnabled = document.getElementById('snapToGridToggle').checked;
            console.log('Snap-to-grid:', snapToGridEnabled ? 'ENABLED' : 'DISABLED');
        }

        function snapToGrid(x, y, element) {
            if (!snapToGridEnabled) {
                return { x: x, y: y };
            }
            
            const pdfViewer = document.getElementById('pdfViewer');
            const viewerRect = pdfViewer.getBoundingClientRect();
            
            // Get all other boxes for alignment guides
            const allBoxes = document.querySelectorAll('.draggable-text-box, .draggable-image-box');
            const otherBoxes = Array.from(allBoxes).filter(box => box !== element);
            
            let snappedX = x;
            let snappedY = y;
            
            // Snap to grid
            const gridX = Math.round(x / GRID_SIZE) * GRID_SIZE;
            const gridY = Math.round(y / GRID_SIZE) * GRID_SIZE;
            
            if (Math.abs(x - gridX) < SNAP_THRESHOLD) {
                snappedX = gridX;
            }
            if (Math.abs(y - gridY) < SNAP_THRESHOLD) {
                snappedY = gridY;
            }
            
            // Snap to other boxes (alignment guides)
            otherBoxes.forEach(box => {
                const boxRect = box.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                
                // Vertical alignment (left, center, right)
                const leftAlign = Math.abs((boxRect.left - viewerRect.left) - (elementRect.left - viewerRect.left + x));
                const centerAlign = Math.abs((boxRect.left + boxRect.width/2 - viewerRect.left) - (elementRect.left + elementRect.width/2 - viewerRect.left + x));
                const rightAlign = Math.abs((boxRect.right - viewerRect.left) - (elementRect.right - viewerRect.left + x));
                
                // Horizontal alignment (top, middle, bottom)
                const topAlign = Math.abs((boxRect.top - viewerRect.top) - (elementRect.top - viewerRect.top + y));
                const middleAlign = Math.abs((boxRect.top + boxRect.height/2 - viewerRect.top) - (elementRect.top + elementRect.height/2 - viewerRect.top + y));
                const bottomAlign = Math.abs((boxRect.bottom - viewerRect.top) - (elementRect.bottom - viewerRect.top + y));
                
                // Apply snapping with visual guides
                if (leftAlign < SNAP_THRESHOLD) {
                    snappedX = (boxRect.left - viewerRect.left) - (elementRect.left - viewerRect.left);
                    showSnapGuide('vertical', boxRect.left - viewerRect.left);
                } else if (centerAlign < SNAP_THRESHOLD) {
                    snappedX = (boxRect.left + boxRect.width/2 - viewerRect.left) - (elementRect.left + elementRect.width/2 - viewerRect.left);
                    showSnapGuide('vertical', boxRect.left + boxRect.width/2 - viewerRect.left);
                } else if (rightAlign < SNAP_THRESHOLD) {
                    snappedX = (boxRect.right - viewerRect.left) - (elementRect.right - viewerRect.left);
                    showSnapGuide('vertical', boxRect.right - viewerRect.left);
                }
                
                if (topAlign < SNAP_THRESHOLD) {
                    snappedY = (boxRect.top - viewerRect.top) - (elementRect.top - viewerRect.top);
                    showSnapGuide('horizontal', boxRect.top - viewerRect.top);
                } else if (middleAlign < SNAP_THRESHOLD) {
                    snappedY = (boxRect.top + boxRect.height/2 - viewerRect.top) - (elementRect.top + elementRect.height/2 - viewerRect.top);
                    showSnapGuide('horizontal', boxRect.top + boxRect.height/2 - viewerRect.top);
                } else if (bottomAlign < SNAP_THRESHOLD) {
                    snappedY = (boxRect.bottom - viewerRect.top) - (elementRect.bottom - viewerRect.top);
                    showSnapGuide('horizontal', boxRect.bottom - viewerRect.top);
                }
            });
            
            return { x: snappedX, y: snappedY };
        }

        function showSnapGuide(type, position) {
            // Remove existing guides
            clearSnapGuides();
            
            const guide = document.createElement('div');
            guide.className = `snap-guide ${type}`;
            guide.style.position = 'absolute';
            
            if (type === 'vertical') {
                guide.style.left = position + 'px';
                guide.style.top = '0';
                guide.style.height = '100%';
            } else {
                guide.style.top = position + 'px';
                guide.style.left = '0';
                guide.style.width = '100%';
            }
            
            document.getElementById('pdfViewer').appendChild(guide);
            
            // Remove guide after a short delay
            setTimeout(() => {
                if (guide.parentNode) {
                    guide.parentNode.removeChild(guide);
                }
            }, 500);
        }

        function clearSnapGuides() {
            const guides = document.querySelectorAll('.snap-guide');
            guides.forEach(guide => guide.remove());
        }

        function updateTextSize(element) {
            if (element.classList.contains('draggable-text-box')) {
                const width = element.offsetWidth;
                const height = element.offsetHeight;
                
                // Only adjust padding to maintain text centering, don't resize font
                // Allow very small padding for very small text boxes
                const padding = Math.max(1, Math.min(width, height) / 10);
                element.style.padding = padding + 'px';
            }
        }

        // PDF Dragging and Zooming Functionality

        function initPDFDragging() {
            pdfViewer = document.getElementById('pdfViewer');
            pdfContent = document.getElementById('pdfContent');
            
            if (!pdfViewer || !pdfContent) return;

            // Mouse events for dragging
            pdfViewer.addEventListener('mousedown', startDragging);
            pdfViewer.addEventListener('mousemove', drag);
            pdfViewer.addEventListener('mouseup', stopDragging);
            pdfViewer.addEventListener('mouseleave', stopDragging);
            
            // Add click handler to deselect text boxes when clicking on empty space
            pdfViewer.addEventListener('click', function(e) {
                // Only deselect if we're clicking on the viewer itself (not on a text box)
                if (e.target === pdfViewer || e.target.id === 'viewer' || e.target.id === 'pdfContent') {
                    document.querySelectorAll('.draggable-text-box').forEach(box => {
                        box.classList.remove('selected');
                    });
                    sessionState.selectedBox = null;
                    updateBoxEditor();
                }
            });
            
            // Touch events for mobile
            pdfViewer.addEventListener('touchstart', startDraggingTouch);
            pdfViewer.addEventListener('touchmove', dragTouch);
            pdfViewer.addEventListener('touchend', stopDragging);
            
            // Wheel event for zooming
            pdfViewer.addEventListener('wheel', handleWheel);
            
            // Prevent context menu
            pdfViewer.addEventListener('contextmenu', e => e.preventDefault());
        }

        function startDragging(e) {
            // Don't start dragging if clicking on controls, if we're in editor mode, or if PDF is locked
            if (e.target.closest('.pdf-controls') || isEditorMode || pdfLocked) return;
            
            isDragging = true;
            lastMousePos = { x: e.clientX, y: e.clientY };
            pdfViewer.classList.add('dragging');
            e.preventDefault();
        }

        function startDraggingTouch(e) {
            if (e.target.closest('.pdf-controls') || isEditorMode || pdfLocked) return;
            
            isDragging = true;
            lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            pdfViewer.classList.add('dragging');
            e.preventDefault();
        }

        function drag(e) {
            if (!isDragging) return;
            
            const currentPos = { x: e.clientX, y: e.clientY };
            const deltaX = currentPos.x - lastMousePos.x;
            const deltaY = currentPos.y - lastMousePos.y;
            
            currentTransform.x += deltaX;
            currentTransform.y += deltaY;
            
            updatePDFTransform();
            lastMousePos = currentPos;
            e.preventDefault();
        }

        function dragTouch(e) {
            if (!isDragging) return;
            
            const currentPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            const deltaX = currentPos.x - lastMousePos.x;
            const deltaY = currentPos.y - lastMousePos.y;
            
            currentTransform.x += deltaX;
            currentTransform.y += deltaY;
            
            updatePDFTransform();
            lastMousePos = currentPos;
            e.preventDefault();
        }

        function stopDragging() {
            isDragging = false;
            pdfViewer.classList.remove('dragging');
        }

        function handleWheel(e) {
            if (isEditorMode || pdfLocked) return; // Don't zoom when editing or if PDF is locked
            
            e.preventDefault();
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(5, currentTransform.scale * zoomFactor));
            
            // Zoom towards mouse position
            const rect = pdfContent.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const scaleChange = newScale / currentTransform.scale;
            currentTransform.x = mouseX - (mouseX - currentTransform.x) * scaleChange;
            currentTransform.y = mouseY - (mouseY - currentTransform.y) * scaleChange;
            currentTransform.scale = newScale;
            
            updatePDFTransform();
        }

        function updatePDFTransform() {
            if (!pdfContent) return;
            
            pdfContent.style.transform = `translate(${currentTransform.x}px, ${currentTransform.y}px) scale(${currentTransform.scale})`;
            
            
            // Update editor canvas if it exists
            if (editorCanvas) {
                editorCanvas.setZoom(currentTransform.scale);
                editorCanvas.renderAll();
            }
            
            // Update image box scaling to match PDF viewer
            updateImageBoxScaling();
            
            // Update text box scaling to match PDF viewer
            updateTextBoxScaling();
            
            // Update PDF area outline to match transform
            updatePdfAreaOutline();
        }
        
        // Function to update image box scaling to match PDF viewer zoom
        function updateImageBoxScaling() {
            const imageBoxes = document.querySelectorAll('.draggable-image-box');
            imageBoxes.forEach(box => {
                // Apply the same scale transform as the PDF viewer
                box.style.transform = `scale(${currentTransform.scale})`;
            });
        }
        
        // Function to update text box scaling to match PDF viewer zoom
        function updateTextBoxScaling() {
            const textBoxes = document.querySelectorAll('.draggable-text-box');
            textBoxes.forEach(box => {
                // Apply the same scale transform as the PDF viewer
                box.style.transform = `scale(${currentTransform.scale})`;
            });
        }
        
        // Function to pre-load all images for html2canvas capture with progress bar
        async function preloadAllImages() {
            const imageBoxes = document.querySelectorAll('.draggable-image-box img');
            
            if (imageBoxes.length === 0) {
                console.log('No images to preload');
                return;
            }

            // Show progress overlay
            const overlay = document.getElementById('imageLoadingOverlay');
            const progressBar = document.getElementById('imageProgressBar');
            const progressText = document.getElementById('imageProgressText');
            const subtitle = document.getElementById('imageLoadingSubtitle');
            
            overlay.classList.add('active');
            subtitle.textContent = `Loading ${imageBoxes.length} image${imageBoxes.length > 1 ? 's' : ''}...`;
            
            let loadedCount = 0;
            const totalImages = imageBoxes.length;
            
            const imagePromises = Array.from(imageBoxes).map((img, index) => {
                return new Promise((resolve, reject) => {
                    if (img.complete && img.naturalWidth > 0) {
                        // Image already loaded
                        loadedCount++;
                        updateProgress(loadedCount, totalImages, progressBar, progressText);
                        resolve();
                    } else {
                        img.onload = () => {
                            loadedCount++;
                            updateProgress(loadedCount, totalImages, progressBar, progressText);
                            resolve();
                        };
                        img.onerror = () => {
                            // Continue even if some images fail
                            loadedCount++;
                            updateProgress(loadedCount, totalImages, progressBar, progressText);
                            resolve();
                        };
                        // Force reload if needed
                        if (img.src) {
                            img.src = img.src;
                        }
                    }
                });
            });
            
            // Wait for all images to load (with timeout)
            await Promise.allSettled(imagePromises);
            
            // Additional wait to ensure images are fully rendered
            subtitle.textContent = 'Finalizing image preparation...';
            await new Promise(resolve => setTimeout(resolve, 100)); // Reduced from 200ms
            
            // Hide progress overlay
            overlay.classList.remove('active');
            
            console.log(`All ${totalImages} images pre-loaded for capture`);
        }

        // Helper function to update progress bar
        function updateProgress(loaded, total, progressBar, progressText) {
            const percentage = Math.round((loaded / total) * 100);
            progressBar.style.width = percentage + '%';
            progressText.textContent = `${percentage}% (${loaded}/${total})`;
        }
        
        // Function to style image boxes for html2canvas capture - matching MERGE-ONLINE behavior
        function styleImageBoxForCapture(img) {
            if (img) {
                // Use natural image dimensions for download (like MERGE-ONLINE)
                img.style.width = img.naturalWidth + 'px';
                img.style.height = img.naturalHeight + 'px';
                img.style.maxWidth = 'none';
                img.style.maxHeight = 'none';
                img.style.objectFit = 'none';
                img.style.display = 'block';
                // Force image to be visible and loaded
                img.style.opacity = '1';
                img.style.visibility = 'visible';
                // Ensure cross-origin is set for html2canvas
                img.crossOrigin = 'anonymous';
                // Remove any transform that might affect capture
                img.style.transform = 'none';
                // Ensure image is fully loaded and rendered
                img.style.imageRendering = 'auto';
                img.style.imageRendering = 'crisp-edges';
            }
        }
        
        // Function to hide UI elements for html2canvas capture
        function hideUIElementsForCapture(clonedViewer) {
            // Remove resize handles
            const resizeHandles = clonedViewer.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                handle.style.display = 'none';
            });
            
            // Hide any other UI elements that shouldn't be captured
            const uiElements = clonedViewer.querySelectorAll('.resize-handle, .pdf-controls');
            uiElements.forEach(element => {
                element.style.display = 'none';
            });
        }

        function togglePDFLock() {
            pdfLocked = !pdfLocked;
            
            // Update cursor style
            if (pdfViewer) {
                pdfViewer.style.cursor = pdfLocked ? 'default' : 'grab';
            }
            
            // Update lock status display
            updatePDFLockStatus();
        }

        function updatePDFLockStatus() {
            // Create or update lock status indicator
            let lockIndicator = document.getElementById('pdfLockIndicator');
            if (!lockIndicator) {
                lockIndicator = document.createElement('div');
                lockIndicator.id = 'pdfLockIndicator';
                lockIndicator.style.cssText = `
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    background: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 4px 8px;
                    border-radius: 3px;
                    font-size: 10px;
                    z-index: 100;
                `;
                document.querySelector('.pdf-viewer').appendChild(lockIndicator);
            }
            
            lockIndicator.textContent = pdfLocked ? 'PDF Locked' : 'PDF Unlocked';
            lockIndicator.style.background = pdfLocked ? 'rgba(220, 53, 69, 0.8)' : 'rgba(40, 167, 69, 0.8)';
            lockIndicator.style.display = 'none'; // Hide lock indicator by default
            
            // Update lock button
            const lockBtn = document.getElementById('pdfLockBtn');
            if (lockBtn) {
                const lockIcon = lockBtn.querySelector('.lock-icon');
                const lockText = lockBtn.querySelector('.lock-text');
                
                if (lockIcon) {
                    lockIcon.textContent = pdfLocked ? '🔒' : '🔓';
                }
                if (lockText) {
                    lockText.textContent = pdfLocked ? 'Unlock PDF' : 'Lock PDF';
                }
                lockBtn.title = pdfLocked ? 'Unlock PDF' : 'Lock PDF';
            }
        }


        function updateEditorStatus(message) {
            // Create status element if it doesn't exist
            let statusElement = document.getElementById('editorStatus');
            if (!statusElement) {
                statusElement = document.createElement('div');
                statusElement.id = 'editorStatus';
                statusElement.className = 'editor-status';
                document.querySelector('.viewer-container').appendChild(statusElement);
            }
            statusElement.textContent = message;
        }

        function saveLayout() {
            if (!editorCanvas) return;

            const layout = {
                page: {
                    size: 'A4',
                    orient: 'portrait'
                },
                objects: []
            };

            // Collect all objects
            editorCanvas.getObjects().forEach(obj => {
                const objectData = {
                    type: obj.type,
                    left: Math.round(obj.left),
                    top: Math.round(obj.top),
                    width: Math.round(obj.width || obj.scaleX * 100),
                    height: Math.round(obj.height || obj.scaleY * 100),
                    meta: obj.meta || {}
                };

                // Add type-specific properties
                if (obj.type === 'text') {
                    objectData.text = obj.text;
                    objectData.fontSize = obj.fontSize;
                    objectData.fontFamily = obj.fontFamily;
                    objectData.fill = obj.fill;
                } else if (obj.type === 'group') {
                    objectData.groupType = 'imagePlaceholder';
                }

                layout.objects.push(objectData);
            });

            // Create and download JSON file
            const jsonString = JSON.stringify(layout, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `layout-A4-portrait-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            updateEditorStatus('Layout saved as JSON');
        }

        // Generate Sample PDF function
        async function generateSamplePDF() {
            try {
                // Create a new PDF document
                const pdfDoc = await PDFLib.PDFDocument.create();
                
                // Add a page
                const page = pdfDoc.addPage([595, 842]); // A4 size
                
                // Get the current ISO timestamp
                const timestamp = new Date().toISOString();
                
                // Add text to the page
                page.drawText(`Generated at ${timestamp}`, {
                    x: 50,
                    y: 750,
                    size: 20,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                // Add some sample content
                page.drawText('This is a sample PDF generated by PDF-lib', {
                    x: 50,
                    y: 700,
                    size: 14,
                    color: PDFLib.rgb(0.2, 0.2, 0.2)
                });
                
                page.drawText('You can use this as a template for testing', {
                    x: 50,
                    y: 670,
                    size: 12,
                    color: PDFLib.rgb(0.4, 0.4, 0.4)
                });
                
                // Save the PDF as bytes
                const pdfBytes = await pdfDoc.save();
                
                // Create a blob and download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                // Create and trigger download
                const link = document.createElement('a');
                link.href = url;
                link.download = `sample-${Date.now()}.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error generating sample PDF:', error);
                alert('Error generating sample PDF: ' + error.message);
            }
        }

        // Download PDFs function - Hybrid High Quality (Single Record Mode Only)
        async function downloadPdfs() {
            try {
                console.log(`=== HYBRID HIGH QUALITY PDF GENERATION (SINGLE RECORD MODE) ===`);
                
                // Step 1: Validate inputs
                console.log('Step 1: Validating inputs...');
                if (!sessionState.templatePdfBytes) {
                    throw new Error('No PDF template loaded');
                }
                if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                    throw new Error('No CSV data loaded');
                }
                if (!sessionState.boxes || sessionState.boxes.length === 0) {
                    throw new Error('No boxes configured');
                }
                
                // Check if we have at least some boxes with CSV data
                // Note: boxes use fieldKey instead of csvColumn
                const hasTextBoxes = sessionState.boxes.some(box => box.type === 'text' && (box.csvColumn || box.fieldKey));
                const hasImageBoxes = sessionState.boxes.some(box => box.boxType === 'image' && (box.csvColumn || box.fieldKey));
                
                if (!hasTextBoxes && !hasImageBoxes) {
                    throw new Error('No boxes with CSV data configured. Please add text boxes or image boxes with CSV field bindings.');
                }
                
                console.log(`✓ Inputs valid: ${sessionState.csvRows.length} CSV rows, ${sessionState.boxes.length} total boxes (${hasTextBoxes ? 'text' : ''}${hasTextBoxes && hasImageBoxes ? ' + ' : ''}${hasImageBoxes ? 'image' : ''})`);

                const downloadBtn = document.getElementById('downloadPdfsBtn');
                downloadBtn.disabled = true;
                downloadBtn.textContent = `Generating Single Record PDFs...`;

                // Step 2: Load JSZip
                console.log('Step 2: Loading JSZip...');
                const JSZipScript = document.getElementById('jszip-cdn');
                if (!window.JSZip && !JSZipScript) {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    script.id = 'jszip-cdn';
                    document.body.appendChild(script);
                    await new Promise(res => { script.onload = res; });
                } else if (!window.JSZip && JSZipScript) {
                    await new Promise(res => { JSZipScript.onload = res; });
                }
                console.log('✓ JSZip loaded');

                const zip = new JSZip();
                const totalRecords = sessionState.csvRows.length;
                
                // Create unified progress bar for entire process
                const progressOverlay = document.createElement('div');
                progressOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 9999;
                `;
                
                const progressContent = document.createElement('div');
                progressContent.style.cssText = `
                    background: white;
                    border-radius: 8px;
                    padding: 30px;
                    text-align: center;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    width: 90%;
                `;
                
                const progressTitle = document.createElement('div');
                progressTitle.style.cssText = `
                    font-size: 18px;
                    font-weight: 600;
                    color: #333;
                    margin-bottom: 20px;
                `;
                progressTitle.textContent = `Generating Single Record PDFs`;
                
                const progressSubtitle = document.createElement('div');
                progressSubtitle.style.cssText = `
                    font-size: 14px;
                    color: #666;
                    margin-bottom: 25px;
                `;
                progressSubtitle.textContent = `Processing ${totalRecords} records...`;
                
                const progressContainer = document.createElement('div');
                progressContainer.style.cssText = `
                    background: #f0f0f0;
                    border-radius: 20px;
                    height: 8px;
                    margin-bottom: 15px;
                    overflow: hidden;
                `;
                
                const progressBar = document.createElement('div');
                progressBar.style.cssText = `
                    background: linear-gradient(90deg, #007bff, #0056b3);
                    height: 100%;
                    width: 0%;
                    transition: width 0.3s ease;
                    border-radius: 20px;
                `;
                
                const progressText = document.createElement('div');
                progressText.style.cssText = `
                    font-size: 12px;
                    color: #666;
                    margin-bottom: 10px;
                `;
                progressText.textContent = '0%';
                
                const progressDetails = document.createElement('div');
                progressDetails.style.cssText = `
                    font-size: 11px;
                    color: #999;
                `;
                progressDetails.textContent = `0 of ${totalRecords} records processed`;
                
                // Assemble progress bar
                progressContainer.appendChild(progressBar);
                progressContent.appendChild(progressTitle);
                progressContent.appendChild(progressSubtitle);
                progressContent.appendChild(progressContainer);
                progressContent.appendChild(progressText);
                progressContent.appendChild(progressDetails);
                progressOverlay.appendChild(progressContent);
                document.body.appendChild(progressOverlay);
                
                // Progress tracking function
                let processedRecords = 0;
                const updateProgress = (step = 1, stepDescription = '') => {
                    processedRecords += step;
                    const percentage = Math.round((processedRecords / totalRecords) * 100);
                    progressBar.style.width = percentage + '%';
                    progressText.textContent = `${percentage}%`;
                    progressDetails.textContent = `${processedRecords} of ${totalRecords} records processed${stepDescription ? ` - ${stepDescription}` : ''}`;
                };

                try {
                    // SINGLE RECORD MODE: One PDF per record
                    console.log('=== SINGLE RECORD MODE ===');
                        
                        for (let recordIndex = 0; recordIndex < totalRecords; recordIndex++) {
                            console.log(`\n--- Processing Record ${recordIndex + 1}/${totalRecords} ---`);
                            
                            const row = sessionState.csvRows[recordIndex];
                            console.log(`Processing record: ${JSON.stringify(row)}`);

                            // Step 3a: Load the template PDF (crisp vector background)
                            console.log('Step 3a: Loading template PDF...');
                            const pdfDoc = await PDFLib.PDFDocument.load(sessionState.templatePdfBytes);
                            
                            // Get the first page
                            const pages = pdfDoc.getPages();
                            if (pages.length === 0) {
                                throw new Error('Template PDF has no pages');
                            }
                            
                            const page = pages[0];
                            
                            // Step 3b: Update UI to show current record data
                            console.log('Step 3b: Updating UI for overlay capture...');
                            
                            // Set current record for this PDF
                            currentRecord = recordIndex;
                            
                            // Update text boxes and image boxes with current record data (single record mode)
                            updateAllTextBoxesForSingleRecord(recordIndex);
                            
                            // Wait for UI to update and ensure images are loaded
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduced from 150ms
                            
                            // Pre-load all images to ensure they're ready for capture
                            progressSubtitle.textContent = 'Loading images...';
                            await preloadAllImages();
                            progressSubtitle.textContent = `Processing ${totalRecords} records...`;
                            
                            // Step 3c: Capture high-resolution overlay (text boxes and image boxes)
                            console.log('Step 3c: Capturing high-res overlays...');
                            const pdfViewer = document.getElementById('pdfViewer');
                            const canvas = document.getElementById('viewer');
                            
                            if (!pdfViewer || !canvas) {
                                throw new Error('PDF viewer not found');
                            }
                            
                            // Get PDF area dimensions
                            const canvasRect = canvas.getBoundingClientRect();
                            const viewerRect = pdfViewer.getBoundingClientRect();
                            const pdfAreaX = canvasRect.left - viewerRect.left;
                            const pdfAreaY = canvasRect.top - viewerRect.top;
                            const pdfAreaWidth = canvasRect.width;
                            const pdfAreaHeight = canvasRect.height;
                            
                            // Calculate optimized scale factor for overlays (balanced quality/speed)
                            let scale = 4; // Reduced from 8 for better performance
                            const img = canvas.querySelector('img');
                            if (img && img.naturalWidth && img.width) {
                                const originalScale = img.naturalWidth / img.width;
                                scale = Math.max(3, originalScale * 1.5); // Reduced multiplier for speed
                            }
                            scale = Math.max(2, Math.min(8, scale)); // Reduced range for faster processing
                            
                            // Capture only the overlay elements with transparency
                            const overlayCanvas = await html2canvas(pdfViewer, {
                                scale: scale,
                                useCORS: true,
                                allowTaint: true,
                                backgroundColor: null, // Transparent background
                                logging: false,
                                x: pdfAreaX,
                                y: pdfAreaY,
                                width: pdfAreaWidth,
                                height: pdfAreaHeight,
                                onclone: (clonedDoc) => {
                                    const clonedViewer = clonedDoc.getElementById('pdfViewer');
                                    if (clonedViewer) {
                                        // Hide the PDF background completely
                                        const pdfCanvas = clonedDoc.getElementById('viewer');
                                        if (pdfCanvas) {
                                            pdfCanvas.style.display = 'none';
                                        }
                                        
                                        // Hide UI elements
                                        const outline = clonedDoc.getElementById('pdfAreaOutline');
                                        if (outline) outline.style.display = 'none';
                                        
                                        const lockIndicator = clonedViewer.querySelector('.pdf-lock-indicator');
                                        if (lockIndicator) lockIndicator.style.display = 'none';
                                        
                                        // Keep only text boxes and image boxes with their styling
                                        const allBoxes = clonedViewer.querySelectorAll('.draggable-text-box, .draggable-image-box');
                                        allBoxes.forEach(box => {
                                            if (box.classList.contains('draggable-text-box')) {
                                                // Text box styling
                                                box.style.border = 'none';
                                                box.style.background = 'transparent';
                                                box.style.boxShadow = 'none';
                                                box.style.outline = 'none';
                                                // Keep font styling for quality
                                                box.style.fontFamily = box.style.fontFamily || 'Arial, sans-serif';
                                                box.style.fontSize = box.style.fontSize || '16px';
                                                box.style.fontWeight = box.style.fontWeight || 'normal';
                                                box.style.color = box.style.color || '#000000';
                                            } else if (box.classList.contains('draggable-image-box')) {
                                                // Image box styling
                                                box.style.border = 'none';
                                                box.style.background = 'transparent';
                                                box.style.boxShadow = 'none';
                                                box.style.outline = 'none';
                                                // Ensure images are visible and properly sized
                                                const img = box.querySelector('img');
                                                if (img) {
                                                    img.style.width = '100%';
                                                    img.style.height = '100%';
                                                    img.style.objectFit = 'contain';
                                                    img.style.display = 'block';
                                                }
                                            }
                                        });
                                        
                                        // Remove resize handles (use !important to override CSS)
                                        const resizeHandles = clonedViewer.querySelectorAll('.resize-handle');
                                        resizeHandles.forEach(handle => {
                                            handle.style.setProperty('display', 'none', 'important');
                                            handle.style.setProperty('opacity', '0', 'important');
                                        });
                                        
                                        // Hide "No Image" text in downloaded PDFs
                                        const imageBoxes = clonedViewer.querySelectorAll('.draggable-image-box');
                                        imageBoxes.forEach(box => {
                                            if (box.textContent === 'No Image') {
                                                box.textContent = '';
                                            }
                                        });
                                        
                                        // Make background transparent
                                        clonedViewer.style.background = 'transparent';
                                        
                                        // Hide PDF controls (top right corner buttons)
                                        const pdfControls = clonedViewer.querySelector('.pdf-controls');
                                        if (pdfControls) pdfControls.style.display = 'none';
                                        
                                        // Fix image stretching for all image boxes before capture
                                        const imageImgs = clonedViewer.querySelectorAll('.draggable-image-box img');
                                        imageImgs.forEach(img => {
                                            if (img.naturalWidth && img.naturalHeight) {
                                                const naturalWidth = img.naturalWidth;
                                                const naturalHeight = img.naturalHeight;
                                                const boxWidth = img.parentElement.offsetWidth;
                                                const boxHeight = img.parentElement.offsetHeight;
                                                
                                                const imageAspect = naturalWidth / naturalHeight;
                                                const boxAspect = boxWidth / boxHeight;
                                                
                                                if (imageAspect > boxAspect) {
                                                    img.style.width = '100%';
                                                    img.style.height = 'auto';
                                                } else {
                                                    img.style.width = 'auto';
                                                    img.style.height = '100%';
                                                }
                                                
                                                img.style.objectFit = 'none';
                                                img.style.objectPosition = 'center';
                                            }
                                        });
                                    }
                                }
                            });
                            

                            
                            // Step 3d: Convert overlay to PNG with transparency
                            console.log('Step 3d: Creating high-resolution JPEG screenshot...');
                            
                            // Capture only the actual PDF canvas area (not entire editor window)
                            const pdfCanvas = document.getElementById('viewer');
                            const canvasRect = pdfCanvas.getBoundingClientRect();
                            const viewerRect = pdfViewer.getBoundingClientRect();
                            
                            // Calculate exact PDF area coordinates within the viewer
                            const pdfAreaX = canvasRect.left - viewerRect.left;
                            const pdfAreaY = canvasRect.top - viewerRect.top;
                            const pdfAreaWidth = canvasRect.width;
                            const pdfAreaHeight = canvasRect.height;
                            
                            console.log(`📐 PDF area: ${pdfAreaWidth}x${pdfAreaHeight} at (${pdfAreaX}, ${pdfAreaY})`);
                            
                            // Capture only the PDF canvas area with high resolution
                            const highResCanvas = await html2canvas(pdfViewer, {
                                scale: 3.0, // Increased resolution for even better quality
                                useCORS: true,
                                allowTaint: true,
                                backgroundColor: '#ffffff', // White background for PDF
                                logging: false,
                                x: pdfAreaX, // Only capture PDF area
                                y: pdfAreaY, // Only capture PDF area
                                width: pdfAreaWidth, // Exact PDF width
                                height: pdfAreaHeight, // Exact PDF height
                                onclone: (clonedDoc) => {
                                    // Hide UI elements in the cloned document
                                    const clonedViewer = clonedDoc.getElementById('pdfViewer');
                                    if (clonedViewer) {
                                        // Hide transform controls and other UI elements
                                        const transformControls = clonedViewer.querySelectorAll('.transform-control, .resize-handle');
                                        transformControls.forEach(control => control.style.display = 'none');
                                        
                                        const pdfControls = clonedViewer.querySelector('.pdf-controls');
                                        if (pdfControls) pdfControls.style.display = 'none';
                                    }
                                }
                            });

                            // Optimize JPEG quality for target file size (1MB-1.5MB)
                            const optimizedImage = await optimizeImageQuality(highResCanvas);
                            const jpegDataUrl = optimizedImage.dataUrl;
                            console.log(`📸 High-res JPEG optimized: Quality ${(optimizedImage.quality * 100).toFixed(1)}%, Size ${(optimizedImage.size / 1024 / 1024).toFixed(2)}MB`);
                            
                            // Step 3e: Create PDF wrapper with exact dimensions (fontmerge approach)
                            console.log('Step 3e: Creating PDF wrapper...');
                            const { jsPDF } = window.jspdf;
                            
                            // Convert pixels to mm (1 inch = 25.4mm, 1 inch = 96 pixels typically)
                            const pixelsToMm = 25.4 / 96;
                            const imgWidthMm = highResCanvas.width * pixelsToMm;
                            const imgHeightMm = highResCanvas.height * pixelsToMm;
                            
                            // Create PDF with exact image dimensions
                            const pdf = new jsPDF({
                                orientation: imgWidthMm > imgHeightMm ? 'landscape' : 'portrait',
                                unit: 'mm',
                                format: [imgWidthMm, imgHeightMm]
                            });
                            
                            // Add JPEG image to PDF at full size (0,0 position, full dimensions)
                            pdf.addImage(jpegDataUrl, 'JPEG', 0, 0, imgWidthMm, imgHeightMm);
                            
                            // Step 3f: Generate PDF bytes
                            console.log('Step 3f: Generating PDF bytes...');
                            const pdfBytes = pdf.output('arraybuffer');
                            
                            // Step 3g: Log size information
                            console.log('Step 3g: Logging PDF size...');
                            const recordNumber = recordIndex + 1;
                            
                            // Step 3h: Add to zip with record-specific naming
                            const fileName = `single_record_${recordNumber}_of_${totalRecords}.pdf`;
                            zip.file(fileName, pdfBytes);
                            
                            const finalSize = (pdfBytes.length / 1024 / 1024).toFixed(2);
                            console.log(`✓ Single record ${recordNumber} added to zip: ${fileName} (${finalSize}MB)`);
                            
                            // Update progress with size info
                            updateProgress(1, `PDF generated (${finalSize}MB)`);
                        }
                    
                    // Step 4: Download zip file
                    console.log('Step 4: Generating zip file...');
                    progressSubtitle.textContent = 'Creating zip file...';
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    
                    // Log size statistics
                    const zipSize = (zipBlob.size / 1024 / 1024).toFixed(2);
                    console.log(`📦 ZIP file generated: ${zipSize}MB for ${totalRecords} PDFs`);
                    console.log(`📊 Average PDF size: ${(zipBlob.size / totalRecords / 1024 / 1024).toFixed(2)}MB per PDF`);
                    
                    // Create download link with single record naming
                    const url = URL.createObjectURL(zipBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `single_record_high_quality_pdfs_${totalRecords}_records.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log(`✓ Single Record high-quality download complete!`);
                    
                } catch (error) {
                    console.error('Error during PDF generation:', error);
                    
                    // Remove progress overlay on error
                    if (progressOverlay && progressOverlay.parentNode) {
                        progressOverlay.parentNode.removeChild(progressOverlay);
                    }
                    
                    throw error;
                } finally {
                    // Restore original state
                    currentPage = 0;
                    updateAllBoxesWithCSVData();
                    
                    // Remove progress overlay
                    if (progressOverlay && progressOverlay.parentNode) {
                        progressOverlay.parentNode.removeChild(progressOverlay);
                    }
                }
                
            } catch (error) {
                console.error('Download failed:', error);
                alert('Error generating PDFs: ' + error.message);
                    
                    // Remove progress overlay on error
                    if (progressOverlay && progressOverlay.parentNode) {
                        progressOverlay.parentNode.removeChild(progressOverlay);
                    }
            } finally {
                    // Remove progress overlay
                    if (progressOverlay && progressOverlay.parentNode) {
                        progressOverlay.parentNode.removeChild(progressOverlay);
                    }
                    
                // Restore button state
                const downloadBtn = document.getElementById('downloadPdfsBtn');
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'Download PDFs';
            }
        }

        // Take Screenshot function
        async function takeScreenshot() {
            try {
                const pdfViewer = document.getElementById('pdfViewer');
                const canvas = document.getElementById('viewer');
                
                if (!pdfViewer || !canvas) {
                    alert('No PDF viewer found. Please upload a PDF first.');
                    return;
                }

                // Show loading state
                const screenshotBtn = document.getElementById('screenshotBtn');
                const originalText = screenshotBtn.textContent;
                screenshotBtn.textContent = '📸 Taking Screenshot...';
                screenshotBtn.disabled = true;

                // Get PDF area dimensions (same as download function)
                const canvasRect = canvas.getBoundingClientRect();
                const viewerRect = pdfViewer.getBoundingClientRect();
                const pdfAreaX = canvasRect.left - viewerRect.left;
                const pdfAreaY = canvasRect.top - viewerRect.top;
                const pdfAreaWidth = canvasRect.width;
                const pdfAreaHeight = canvasRect.height;

                // Calculate high-quality scale factor (same as download function)
                let scale = 6;
                const img = canvas.querySelector('img');
                if (img && img.naturalWidth && img.width) {
                    const originalScale = img.naturalWidth / img.width;
                    scale = Math.max(6, originalScale * 1.5);
                }
                scale = Math.max(4, Math.min(12, scale));

                // Use html2canvas to capture only the PDF area
                const capturedCanvas = await html2canvas(pdfViewer, {
                    scale: scale,
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: '#ffffff',
                    logging: false,
                    x: pdfAreaX,
                    y: pdfAreaY,
                    width: pdfAreaWidth,
                    height: pdfAreaHeight,
                    onclone: (clonedDoc) => {
                        const clonedViewer = clonedDoc.getElementById('pdfViewer');
                        if (clonedViewer) {
                            // Hide UI elements that shouldn't be in screenshot
                            const outline = clonedDoc.getElementById('pdfAreaOutline');
                            if (outline) outline.style.display = 'none';
                            
                            const lockIndicator = clonedViewer.querySelector('.pdf-lock-indicator');
                            if (lockIndicator) lockIndicator.style.display = 'none';
                            
                            // Hide PDF controls (top right corner buttons)
                            const pdfControls = clonedViewer.querySelector('.pdf-controls');
                            if (pdfControls) pdfControls.style.display = 'none';
                            
                            // Remove borders and backgrounds from text boxes for clean screenshot
                            const allBoxes = clonedViewer.querySelectorAll('.draggable-text-box');
                            allBoxes.forEach(box => {
                                box.style.border = 'none';
                                box.style.background = 'transparent';
                                box.style.boxShadow = 'none';
                                box.style.outline = 'none';
                            });
                            
                            // Remove resize handles
                            const resizeHandles = clonedViewer.querySelectorAll('.resize-handle');
                            resizeHandles.forEach(handle => {
                                handle.style.display = 'none';
                            });
                        }
                    }
                });

                // Convert canvas to blob
                capturedCanvas.toBlob((blob) => {
                    // Create download link
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `pdf-screenshot-${Date.now()}.png`;
                    
                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Clean up
                    URL.revokeObjectURL(url);
                    
                    // Restore button state
                    screenshotBtn.textContent = originalText;
                    screenshotBtn.disabled = false;
                    
                    console.log('Screenshot taken and downloaded successfully');
                }, 'image/png', 0.95);

            } catch (error) {
                console.error('Screenshot failed:', error);
                alert('Error taking screenshot: ' + error.message);
                
                // Restore button state on error
                const screenshotBtn = document.getElementById('screenshotBtn');
                screenshotBtn.textContent = '📸 TAKE SCREENSHOT';
                screenshotBtn.disabled = false;
            }
        }

        // Download Current PDF function
        async function downloadCurrentPdf() {
            try {
                if (!sessionState.templatePdfBytes) {
                    alert('Please upload a PDF template first');
                    return;
                }

                // Show loading state
                const downloadBtn = document.getElementById('screenshotBtn');
                const originalText = downloadBtn.textContent;
                downloadBtn.textContent = '📄 Generating PDF...';
                downloadBtn.disabled = true;

                // Step 1: Load the template PDF
                console.log('Step 1: Loading template PDF...');
                const pdfDoc = await PDFLib.PDFDocument.load(sessionState.templatePdfBytes);
                const page = pdfDoc.getPages()[0];

                // Step 2: Pre-load all images
                console.log('Step 2: Pre-loading images...');
                await preloadAllImages();

                // Step 3: Capture high-resolution overlay (text boxes and image boxes)
                console.log('Step 3: Capturing high-res overlays...');
                const pdfViewer = document.getElementById('pdfViewer');
                const canvas = document.getElementById('viewer');
                
                if (!pdfViewer || !canvas) {
                    throw new Error('PDF viewer not found');
                }

                // Wait for UI to update
                await new Promise(resolve => setTimeout(resolve, 100));

                // Get PDF area dimensions (same as multi-page function)
                const canvasRect = canvas.getBoundingClientRect();
                const viewerRect = pdfViewer.getBoundingClientRect();
                const pdfAreaX = canvasRect.left - viewerRect.left;
                const pdfAreaY = canvasRect.top - viewerRect.top;
                const pdfAreaWidth = canvasRect.width;
                const pdfAreaHeight = canvasRect.height;
                
                // Calculate optimized scale factor for overlays (same as multi-page function)
                let scale = 4;
                const img = canvas.querySelector('img');
                if (img && img.naturalWidth && img.width) {
                    const originalScale = img.naturalWidth / img.width;
                    scale = Math.max(3, originalScale * 1.5);
                }
                scale = Math.max(2, Math.min(8, scale));
                
                // Capture only the overlay elements with transparency (same as multi-page function)
                const overlayCanvas = await html2canvas(pdfViewer, {
                    scale: scale,
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: null,
                    logging: false,
                    x: pdfAreaX,
                    y: pdfAreaY,
                    width: pdfAreaWidth,
                    height: pdfAreaHeight,
                    onclone: (clonedDoc) => {
                        const clonedViewer = clonedDoc.getElementById('pdfViewer');
                        if (clonedViewer) {
                            // Hide the PDF background completely
                            const pdfCanvas = clonedDoc.getElementById('viewer');
                            if (pdfCanvas) {
                                pdfCanvas.style.display = 'none';
                            }
                            
                            // Hide UI elements
                            const outline = clonedDoc.getElementById('pdfAreaOutline');
                            if (outline) outline.style.display = 'none';
                            
                            const lockIndicator = clonedViewer.querySelector('.pdf-lock-indicator');
                            if (lockIndicator) lockIndicator.style.display = 'none';
                            
                            // Keep only text boxes and image boxes with their styling
                            const allBoxes = clonedViewer.querySelectorAll('.draggable-text-box, .draggable-image-box');
                            allBoxes.forEach(box => {
                                if (box.classList.contains('draggable-text-box')) {
                                    // Text box styling
                                    box.style.border = 'none';
                                    box.style.background = 'transparent';
                                    box.style.boxShadow = 'none';
                                    box.style.outline = 'none';
                                    // Keep font styling for quality
                                    box.style.fontFamily = box.style.fontFamily || 'Arial, sans-serif';
                                    box.style.fontSize = box.style.fontSize || '16px';
                                    box.style.fontWeight = box.style.fontWeight || 'normal';
                                    box.style.color = box.style.color || '#000000';
                                } else if (box.classList.contains('draggable-image-box')) {
                                    // Image box styling
                                    box.style.border = 'none';
                                    box.style.background = 'transparent';
                                    box.style.boxShadow = 'none';
                                    box.style.outline = 'none';
                                    // Ensure images are visible and properly sized
                                    const img = box.querySelector('img');
                                    if (img) {
                                        // Use natural dimensions to prevent stretching
                                        const naturalWidth = img.naturalWidth;
                                        const naturalHeight = img.naturalHeight;
                                        const boxWidth = box.offsetWidth;
                                        const boxHeight = box.offsetHeight;
                                        
                                        // Calculate aspect ratio and fit image properly
                                        const imageAspect = naturalWidth / naturalHeight;
                                        const boxAspect = boxWidth / boxHeight;
                                        
                                        if (imageAspect > boxAspect) {
                                            // Image is wider than box - fit to width
                                            img.style.width = '100%';
                                            img.style.height = 'auto';
                                        } else {
                                            // Image is taller than box - fit to height
                                            img.style.width = 'auto';
                                            img.style.height = '100%';
                                        }
                                        
                                        img.style.objectFit = 'none';
                                        img.style.objectPosition = 'center';
                                        img.style.display = 'block';
                                    }
                                    
                                    // Hide "No Image" text in downloaded PDFs
                                    if (box.textContent === 'No Image') {
                                        box.textContent = '';
                                    }
                                }
                            });
                            
                            // Remove resize handles (use !important to override CSS)
                            const resizeHandles = clonedViewer.querySelectorAll('.resize-handle');
                            resizeHandles.forEach(handle => {
                                handle.style.setProperty('display', 'none', 'important');
                                handle.style.setProperty('opacity', '0', 'important');
                            });
                            
                            // Hide "No Image" text in downloaded PDFs
                            const imageBoxes = clonedViewer.querySelectorAll('.draggable-image-box');
                            imageBoxes.forEach(box => {
                                if (box.textContent === 'No Image') {
                                    box.textContent = '';
                                }
                            });
                            
                            // Make background transparent
                            clonedViewer.style.background = 'transparent';
                            
                            // Hide PDF controls (top right corner buttons)
                            const pdfControls = clonedViewer.querySelector('.pdf-controls');
                            if (pdfControls) pdfControls.style.display = 'none';
                        }
                    }
                });

                // Step 4: Create high-resolution JPEG screenshot (fontmerge approach)
                console.log('Step 4: Creating high-resolution JPEG screenshot...');
                
                // Capture only the actual PDF canvas area (not entire editor window)
                const pdfCanvas = document.getElementById('viewer');
                const canvasRect = pdfCanvas.getBoundingClientRect();
                const viewerRect = pdfViewer.getBoundingClientRect();
                
                // Calculate exact PDF area coordinates within the viewer
                const pdfAreaX = canvasRect.left - viewerRect.left;
                const pdfAreaY = canvasRect.top - viewerRect.top;
                const pdfAreaWidth = canvasRect.width;
                const pdfAreaHeight = canvasRect.height;
                
                console.log(`📐 PDF area: ${pdfAreaWidth}x${pdfAreaHeight} at (${pdfAreaX}, ${pdfAreaY})`);
                
                // Capture only the PDF canvas area with high resolution
                const highResCanvas = await html2canvas(pdfViewer, {
                    scale: 3.0, // Increased resolution for even better quality
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: '#ffffff', // White background for PDF
                    logging: false,
                    x: pdfAreaX, // Only capture PDF area
                    y: pdfAreaY, // Only capture PDF area
                    width: pdfAreaWidth, // Exact PDF width
                    height: pdfAreaHeight, // Exact PDF height
                    onclone: (clonedDoc) => {
                        // Hide UI elements in the cloned document
                        const clonedViewer = clonedDoc.getElementById('pdfViewer');
                        if (clonedViewer) {
                            // Hide transform controls and other UI elements
                            const transformControls = clonedViewer.querySelectorAll('.transform-control, .resize-handle');
                            transformControls.forEach(control => control.style.display = 'none');
                            
                            const pdfControls = clonedViewer.querySelector('.pdf-controls');
                            if (pdfControls) pdfControls.style.display = 'none';
                        }
                    }
                });

                // Optimize JPEG quality for target file size (1MB-1.5MB)
                const optimizedImage = await optimizeImageQuality(highResCanvas);
                const jpegDataUrl = optimizedImage.dataUrl;
                console.log(`📸 High-res JPEG optimized: Quality ${(optimizedImage.quality * 100).toFixed(1)}%, Size ${(optimizedImage.size / 1024 / 1024).toFixed(2)}MB`);

                // Step 5: Create PDF wrapper with exact dimensions (fontmerge approach)
                console.log('Step 5: Creating PDF wrapper...');
                const { jsPDF } = window.jspdf;
                
                // Convert pixels to mm (1 inch = 25.4mm, 1 inch = 96 pixels typically)
                const pixelsToMm = 25.4 / 96;
                const imgWidthMm = highResCanvas.width * pixelsToMm;
                const imgHeightMm = highResCanvas.height * pixelsToMm;
                
                // Create PDF with exact image dimensions
                const pdf = new jsPDF({
                    orientation: imgWidthMm > imgHeightMm ? 'landscape' : 'portrait',
                    unit: 'mm',
                    format: [imgWidthMm, imgHeightMm]
                });
                
                // Add JPEG image to PDF at full size (0,0 position, full dimensions)
                pdf.addImage(jpegDataUrl, 'JPEG', 0, 0, imgWidthMm, imgHeightMm);
                
                // Step 6: Generate PDF bytes
                console.log('Step 6: Generating PDF bytes...');
                const pdfBytes = pdf.output('arraybuffer');
                
                // Log size information
                const finalSize = (pdfBytes.length / 1024 / 1024).toFixed(2);
                console.log(`📄 Single PDF generated: ${finalSize}MB`);
                
                // Create download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `current-pdf-${Date.now()}.pdf`;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up
                URL.revokeObjectURL(url);
                
                // Restore button state
                downloadBtn.textContent = originalText;
                downloadBtn.disabled = false;
                
                console.log('Current PDF downloaded successfully');
                
            } catch (error) {
                console.error('Download failed:', error);
                alert('Error downloading PDF: ' + error.message);
                
                // Restore button state on error
                const downloadBtn = document.getElementById('screenshotBtn');
                downloadBtn.textContent = '📄 Download Current PDF';
                downloadBtn.disabled = false;
            }
        }

        // Helper function to convert hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Generate From Template function
        async function generateFromTemplate() {
            try {
                if (!sessionState.templatePdfBytes) {
                    alert('Please select a PDF template first');
                    return;
                }

                // Load the template PDF using the Uint8Array copy
                const pdfDoc = await PDFLib.PDFDocument.load(sessionState.templatePdfBytes);
                
                // Embed the Helvetica Bold font
                const helveticaBoldFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
                
                // Get the first page
                const pages = pdfDoc.getPages();
                if (pages.length === 0) {
                    throw new Error('Template PDF has no pages');
                }
                
                const page = pages[0];
                
                // Get current timestamp for demo data
                const timestamp = new Date().toISOString();
                const dateStr = new Date().toLocaleDateString();
                
                // Add text overlay at fixed positions
                page.drawText('TICKET #12345', {
                    x: 100,
                    y: 700,
                    size: 16,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                page.drawText(`Date: ${dateStr}`, {
                    x: 100,
                    y: 650,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.2, 0.2, 0.2)
                });
                
                page.drawText(`Generated: ${timestamp}`, {
                    x: 100,
                    y: 620,
                    size: 10,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.4, 0.4, 0.4)
                });
                
                // Add some sample fields
                page.drawText('Customer: John Doe', {
                    x: 100,
                    y: 580,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                page.drawText('Amount: $99.99', {
                    x: 100,
                    y: 550,
                    size: 14,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.8, 0, 0)
                });
                
                page.drawText('Status: PAID', {
                    x: 100,
                    y: 520,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0.6, 0)
                });
                
                // Save the modified PDF
                const pdfBytes = await pdfDoc.save();
                
                // Create a blob and download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                // Create and trigger download
                const link = document.createElement('a');
                link.href = url;
                link.download = `template-generated-${Date.now()}.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error generating from template:', error);
                alert('Error generating from template: ' + error.message);
            }
        }



        function parseCSVFile(file) {
            console.log('parseCSVFile function called with file:', file);
            console.log('Parsing CSV file:', file.name, file.size);
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    console.log('CSV parsing complete:', results);
                    if (results.errors.length > 0) {
                        console.error('CSV parsing errors:', results.errors);
                        alert('Error parsing CSV file. Please check the file format.');
                        return;
                    }

                    // Store CSV data in session state and global variable
                    sessionState.csv = file;
                    sessionState.csvRows = results.data;
                    csvData = results.data;
                    
                    // Add columns property to csvData for compatibility with MERGE-ONLINE
                    if (results.data && results.data.length > 0) {
                        csvData.columns = Object.keys(results.data[0]);
                        sessionState.csvColumns = Object.keys(results.data[0]); // Add this line
                    }
                    
                    currentRecord = 0;
                    

                    

                    
                    // Display preview
                    displayCSVPreview(results.data);
                    
                    // Show record navigation
                    showRecordNavigation();
                    
                    // Update file label
                    document.getElementById('csvLabel').textContent = file.name;
                    
                    // Update box editor if a box is selected
                    if (sessionState.selectedBox) {
                        updateBoxEditorValues(sessionState.selectedBox);
                    }
                    
                    // Update all text boxes with CSV data
                    updateAllBoxesWithCSVData();
                    
                    // Update download button state
                    updateDownloadButtonState();
                    
                    // Update records info
                    updateRecordsInfo();
                    
                    // Initialize page navigation
                    updatePageNavigation();
                    
                    // Update create records button state
                    updateCreateRecordsButtonState();
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    alert('Error reading CSV file: ' + error.message);
                }
            });
        }

        function displayCSVPreview(data) {
            console.log('Displaying CSV preview with data:', data);
            if (!data || data.length === 0) {
                console.log('No CSV data to display');
                return;
            }

            // CSV preview section was removed, so we just log the data
            console.log('CSV loaded successfully:', data.length, 'rows');
            console.log('CSV columns:', Object.keys(data[0]));
        }

        function toggleCSVPreview() {
            // CSV preview functionality was removed
        }

        function resetSession() {
            // Clear session state
            sessionState = {
                templatePdf: null,
                templatePdfBytes: null,
                csv: null,
                csvRows: [],
                layout: null,
                boxes: [],
                selectedBox: null
            };
            
            // Reset box counter
            boxCounter = 0;
            currentBoxId = null;
            
            // Clear editor canvas
            if (editorCanvas) {
                editorCanvas.clear();
            }
            
            // Hide box editor
            updateBoxEditor();

            // Clear current variables
            currentPdf = null;
            currentFile = null;
            serverPdfUrl = null;

            // Reset UI
            const fileLabel = document.getElementById('fileLabel');
            const noPdf = document.getElementById('noPdf');
            const loadingPdf = document.getElementById('loadingPdf');
            const viewer = document.getElementById('viewer');
            
            if (fileLabel) fileLabel.textContent = 'Click to select PDF file';
            if (noPdf) {
                noPdf.style.display = 'block';
                noPdf.innerHTML = `
                <h3>No PDF selected</h3>
                <p>Choose a PDF file to start viewing</p>
            `;
            }
            if (loadingPdf) loadingPdf.style.display = 'none';
            if (viewer) viewer.style.display = 'none';

            // Clear file inputs
            const pdfFileInput = document.getElementById('pdfFile');
            const csvFileInput = document.getElementById('csvFile');
            const csvLabel = document.getElementById('csvLabel');
            
            if (pdfFileInput) pdfFileInput.value = '';
            if (csvFileInput) csvFileInput.value = '';
            if (csvLabel) csvLabel.textContent = 'Click to select CSV file';
            // csvPreview element was removed

            // Disable Generate From Template button
                            // generateFromTemplateBtn was removed
            
            // Disable Download PDFs button
            const downloadBtn = document.getElementById('downloadPdfsBtn');
            if (downloadBtn) {
                downloadBtn.disabled = true;
            }



            // Revoke any ObjectURLs if they exist
            if (serverPdfUrl && serverPdfUrl.startsWith('blob:')) {
                URL.revokeObjectURL(serverPdfUrl);
            }
        }

        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('collapsed');
        }

        // Font Management Functions
        function initializeFontHandling() {
            const fontUploadArea = document.getElementById('fontUploadArea');
            const fontUploadInput = document.getElementById('fontUploadInput');
            const addFontUrlBtn = document.getElementById('addFontUrlBtn');
            const fontUrlInput = document.getElementById('fontUrlInput');

            if (fontUploadArea && fontUploadInput) {
                fontUploadArea.addEventListener('click', () => fontUploadInput.click());
                fontUploadArea.addEventListener('dragover', e => {
                    e.preventDefault();
                    fontUploadArea.classList.add('dragover');
                });
                fontUploadArea.addEventListener('dragleave', e => {
                    e.preventDefault();
                    fontUploadArea.classList.remove('dragover');
                });
                fontUploadArea.addEventListener('drop', e => {
                    e.preventDefault();
                    fontUploadArea.classList.remove('dragover');
                    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                        handleFontUpload(e.dataTransfer.files[0]);
                    }
                });
                fontUploadInput.addEventListener('change', e => {
                    if (fontUploadInput.files && fontUploadInput.files[0]) {
                        handleFontUpload(fontUploadInput.files[0]);
                    }
                });
            }

            if (addFontUrlBtn && fontUrlInput) {
                addFontUrlBtn.addEventListener('click', handleGoogleFontUrl);
            }
            
            // Initialize font dropdowns
            updateFontDropdowns();
        }

        function handleFontUpload(file) {
            const status = document.getElementById('fontUploadStatus');
            
            if (!file.name.match(/\.(ttf|otf)$/i)) {
                status.textContent = 'Only .ttf and .otf files are allowed.';
                status.className = 'font-status error';
                return;
            }
            
            status.textContent = 'Processing font...';
            status.className = 'font-status';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const base64 = e.target.result.split(',')[1];
                    const fontName = file.name.replace(/\.(ttf|otf)$/i, '');
                    const fileExtension = file.name.match(/\.(ttf|otf)$/i)[1].toLowerCase();
                    const format = fileExtension === 'ttf' ? 'truetype' : 'opentype';
                    
                    // Remove existing font-face if it exists
                    const existingStyle = document.getElementById(`font-face-${fontName}`);
                    if (existingStyle) {
                        existingStyle.remove();
                    }
                    
                    // Create @font-face rule with data URL
                    const style = document.createElement('style');
                    style.id = `font-face-${fontName}`;
                    style.textContent = `
                        @font-face {
                            font-family: '${fontName}';
                            src: url(data:font/${fileExtension};base64,${base64}) format('${format}');
                            font-display: swap;
                        }
                    `;
                    document.head.appendChild(style);
                    
                    // Add to available fonts if not already present
                    if (!sessionState.availableFonts) {
                        sessionState.availableFonts = [];
                    }
                    if (!sessionState.availableFonts.includes(fontName)) {
                        sessionState.availableFonts.push(fontName);
                        updateFontDropdowns();
                    }
                    
                    // Set as default font for new text boxes
                    sessionState.defaultFontFamily = fontName;
                    
                    // Update the format all dropdown to show the new font
                    const formatAllFontFamily = document.getElementById('formatAllFontFamily');
                    if (formatAllFontFamily) {
                        formatAllFontFamily.value = fontName;
                    }
                    
                    // Apply font based on current mode
                    if (applyMode === 'all') {
                        // Update ALL existing text boxes that use the old default
                        sessionState.boxes.forEach(box => {
                            if (box.boxType === 'text' && (!box.fontFamily || box.fontFamily === 'Arial')) {
                                box.fontFamily = fontName;
                                if (box.element) {
                                    box.element.style.fontFamily = `'${fontName}', Arial, sans-serif`;
                                }
                            }
                        });
                        console.log('Font uploaded and applied to ALL text boxes');
                    } else {
                        // Only update the selected text box
                        if (sessionState.selectedBox && sessionState.selectedBox.boxType === 'text') {
                            sessionState.selectedBox.fontFamily = fontName;
                            updateTextBoxFont(sessionState.selectedBox);
                            // Update the dropdown to show the new font
                            const boxFontFamily = document.getElementById('boxFontFamily');
                            if (boxFontFamily) {
                                boxFontFamily.value = fontName;
                            }
                            console.log('Font uploaded and applied to SELECTED text box only');
                        } else {
                            console.log('Font uploaded but no text box selected in "Selected Only" mode');
                        }
                    }
                    
                    if (applyMode === 'all') {
                        status.textContent = `Font "${fontName}" loaded successfully and applied to all text boxes!`;
                    } else {
                        status.textContent = `Font "${fontName}" loaded successfully and applied to selected text box!`;
                    }
                    status.className = 'font-status success';
                    
                } catch (error) {
                    console.error('Error processing font:', error);
                    status.textContent = 'Error processing font file.';
                    status.className = 'font-status error';
                }
            };
            
            reader.onerror = function() {
                status.textContent = 'Error reading font file.';
                status.className = 'font-status error';
            };
            
            reader.readAsDataURL(file);
        }

        async function handleGoogleFontUrl() {
            const urlInput = document.getElementById('fontUrlInput');
            const status = document.getElementById('fontUrlStatus');
            const url = urlInput.value.trim();
            
            if (!url) {
                status.textContent = 'Please paste a Google Fonts URL.';
                status.className = 'font-status error';
                return;
            }
            
            if (url.includes('fonts.google.com/share')) {
                status.textContent = 'This is a share link. Please use the "Use on the web" link from Google Fonts.';
                status.className = 'font-status error';
                return;
            }
            
            status.textContent = 'Adding font...';
            status.className = 'font-status';
            
            if (url.startsWith('http') && url.includes('fonts.googleapis.com')) {
                let fontName = await getFontFamilyFromGoogleFontsUrl(url);
                if (!fontName) {
                    status.textContent = 'Could not determine font name. Please check the URL.';
                    status.className = 'font-status error';
                    return;
                }
                
                if (!document.querySelector(`link[href="${url}"]`)) {
                    const link = document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = url;
                    document.head.appendChild(link);
                }
                
                if (!availableFonts.includes(fontName)) {
                    availableFonts.push(fontName);
                    updateFontDropdown();
                }
                
                // Update current text box if selected
                if (sessionState.selectedBox && sessionState.selectedBox.type === 'text') {
                    sessionState.selectedBox.fontFamily = fontName;
                    updateTextBoxFont(sessionState.selectedBox);
                    // Update the dropdown to show the new font
                    document.getElementById('boxFontFamily').value = fontName;
                }
                
                status.textContent = `Font "${fontName}" added successfully!`;
                status.className = 'font-status success';
                urlInput.value = '';
                
            } else {
                status.textContent = 'Please enter a valid Google Fonts URL.';
                status.className = 'font-status error';
            }
        }

        async function getFontFamilyFromGoogleFontsUrl(url) {
            try {
                const res = await fetch(url);
                const css = await res.text();
                const match = css.match(/font-family:\s*'([^']+)'/);
                if (match) {
                    return match[1];
                }
            } catch (e) {
                console.warn('Could not fetch Google Fonts CSS:', e);
            }
            
            // Fallback: try to parse from URL
            const urlMatch = url.match(/family=([^:&]+)/);
            if (urlMatch) {
                return decodeURIComponent(urlMatch[1]).replace(/\+/g, ' ').split(':')[0];
            }
            return '';
        }

        function updateFontDropdown() {
            const fontSelect = document.getElementById('boxFontFamily');
            if (!fontSelect) return;
            
            // Store current selection
            const currentValue = fontSelect.value;
            
            // Clear and rebuild options
            fontSelect.innerHTML = '';
            availableFonts.forEach(font => {
                const option = document.createElement('option');
                option.value = font;
                option.textContent = font;
                option.selected = font === currentValue;
                fontSelect.appendChild(option);
            });
        }

        function updateTextBoxFont(box) {
            if (!box || box.type !== 'text') return;
            
            console.log('updateTextBoxFont called for box:', box, 'with font:', box.fontFamily);
            
            // Check if we're in "Selected Only" mode and this is not the selected box
            if (applyMode === 'selected' && sessionState.selectedBox && box !== sessionState.selectedBox) {
                console.log('Skipping font update for non-selected box in "Selected Only" mode');
                return;
            }
            
            const element = box.element;
            if (element) {
                element.style.fontFamily = `'${box.fontFamily}', Arial, sans-serif`;
                element.style.fontSize = (box.fontSize || 16) + 'px';
                element.style.color = box.color || '#000000';
                element.style.fontWeight = box.bold ? 'bold' : 'normal';
                element.style.fontStyle = box.italic ? 'italic' : 'normal';
                element.style.textDecoration = box.underline ? 'underline' : 'none';
                
                // Set text alignment and flex properties for consistent positioning
                element.style.textAlign = box.textAlign || 'center';
                element.style.justifyContent = box.textAlign === 'left' ? 'flex-start' : 
                                             box.textAlign === 'right' ? 'flex-end' : 'center';
                
                // Don't auto-resize - let user manually resize to reveal hidden text
                // This keeps text position consistent regardless of content length
            }
        }

        // CSV Data Binding Functions
        function showRecordNavigation() {
            // Record navigation was moved to the main interface
            // This function is kept for compatibility but does nothing
        }

        function updateRecordInfo() {
            // recordInfo element was removed with the CSV Data drawer
            // This function is kept for compatibility but does nothing
        }

        async function updateAllBoxesWithCSVData() {
            console.log('updateAllBoxesWithCSVData called - this will update ALL boxes');
            console.log('Updating all boxes with CSV data. Current page:', currentPage, 'Records per page:', recordsPerPage);
            console.log('Total boxes:', sessionState.boxes.length);
            console.log('CSV data available:', sessionState.csvRows ? sessionState.csvRows.length : 0, 'rows');
            
            // Calculate which records should be shown on the current page
            const startRecord = currentPage * recordsPerPage;
            const endRecord = Math.min(startRecord + recordsPerPage, sessionState.csvRows ? sessionState.csvRows.length : 0);
            
            console.log(`Page ${currentPage + 1}: Showing records ${startRecord + 1}-${endRecord}`);
            
            // Process all boxes with unified record index calculation
            sessionState.boxes.forEach(async (box, boxIndex) => {
                if (box.type === 'text' && box.fieldKey) {
                    // Calculate record index using localIndex (position within page layout)
                    const localIndex = boxIndex % recordsPerPage;
                    const recordIndex = currentPage * recordsPerPage + localIndex;
                    console.log(`Text box ${boxIndex} - Local index: ${localIndex}, Record index: ${recordIndex}, Field key: ${box.fieldKey}`);
                    updateTextBoxWithCSVData(box, recordIndex);
                } else if (box.boxType === 'image' && box.fieldKey) {
                    // Calculate record index using localIndex (position within page layout)
                    const localIndex = boxIndex % recordsPerPage;
                    const recordIndex = currentPage * recordsPerPage + localIndex;
                    console.log(`Image box ${boxIndex} - Local index: ${localIndex}, Record index: ${recordIndex}, Field key: ${box.fieldKey}`);
                    await updateImageBoxWithCSVData(box, recordIndex);
                }
            });
        }

        function updateAllTextBoxesForSingleRecord(recordIndex) {
            sessionState.boxes.forEach(box => {
                if (box.type === 'text' && box.fieldKey) {
                    // In single record mode, all text boxes show the same record
                    updateTextBoxForSingleRecord(box, recordIndex);
                } else if (box.boxType === 'image' && box.fieldKey) {
                    // In single record mode, all image boxes show the same record
                    updateImageBoxForSingleRecord(box, recordIndex);
                }
            });
        }

        function updateTextBoxWithCSVData(box, recordIndex) {
            if (!box || !box.element || !sessionState.csvRows) return;
            
            console.log(`Text box update - Record index: ${recordIndex}, Field key: ${box.fieldKey}`);
            
            if (recordIndex >= sessionState.csvRows.length) {
                // No more records, show empty
                console.log(`No more records available for text box, showing empty`);
                updateTextBoxContentSafely(box.element, '');
                return;
            }
            
            const row = sessionState.csvRows[recordIndex];
            const text = row[box.fieldKey] || '';
            
            console.log(`Text box - Record ${recordIndex}: "${text}"`);
            
            // Update the text content while preserving resize handles
            updateTextBoxContentSafely(box.element, text);
            
            // Apply formatting
            updateTextBoxFont(box);
        }

        function updateTextBoxForSingleRecord(box, recordIndex) {
            if (!box || !box.element || !sessionState.csvRows) return;
            
            if (recordIndex >= sessionState.csvRows.length) {
                // No more records, show empty
                updateTextBoxContentSafely(box.element, '');
                return;
            }
            
            const row = sessionState.csvRows[recordIndex];
            const text = row[box.fieldKey] || '';
            
            // Update the text content while preserving resize handles
            updateTextBoxContentSafely(box.element, text);
            
            // Apply formatting
            updateTextBoxFont(box);
        }

        function updateImageBoxForSingleRecord(box, recordIndex) {
            if (!box || !box.element || !sessionState.csvRows) return;
            
            if (recordIndex >= sessionState.csvRows.length) {
                // No more records, show placeholder
                box.element.textContent = 'No Image';
                box.element.style.border = '2px dashed #ccc';
                box.element.style.background = 'transparent';
                return;
            }
            
            const row = sessionState.csvRows[recordIndex];
            const imageUrl = row[box.fieldKey] || '';
            
            // Load the new image
            if (imageUrl && imageUrl.trim() !== '') {
                loadImageFromUrl(imageUrl, box.element);
            } else {
                // Show placeholder if no image URL
                box.element.textContent = 'No Image';
                box.element.style.border = '2px dashed #ccc';
                box.element.style.background = 'transparent';
            }
        }
        
        function updateTextBoxWithMappedCSVData(box) {
            if (!box || !box.element || !csvData) return;
            
            const mappedRowIndex = textBoxMappings[box.id];
            if (mappedRowIndex === undefined || !csvData[mappedRowIndex]) return;
            
            const row = csvData[mappedRowIndex];
            const text = row[box.csvColumn] || '';
            
            // Update the text content while preserving resize handles
            updateTextBoxContentSafely(box.element, text);
            
            // Apply formatting
            updateTextBoxFont(box);
        }

        function updateTextBoxContent(box) {
            if (!box || !box.element) return;
            
            let text = '';
            
            if (box.csvColumn && csvData && csvData[currentRecord]) {
                // Use CSV data
                text = csvData[currentRecord][box.csvColumn] || '';
            } else {
                // Use static text
                text = box.staticText || 'Sample Text';
            }
            
            updateTextBoxContentSafely(box.element, text);
            updateTextBoxFont(box);
        }

        async function updateImageBoxWithCSVData(box, recordIndex) {
            console.log('updateImageBoxWithCSVData called with:', box, 'recordIndex:', recordIndex);
            if (box.boxType !== 'image' || !box.fieldKey) {
                console.log('Box is not image type or no field key selected');
                return;
            }
            
            // Get current CSV row data
            const currentRow = sessionState.csvRows && sessionState.csvRows[recordIndex];
            if (!currentRow) {
                console.log('No current row data available');
                return;
            }
            
            console.log(`Image box update - Record index: ${recordIndex}, Field key: ${box.fieldKey}`);
            
            if (recordIndex >= sessionState.csvRows.length) {
                console.log(`No more records available for image box, showing placeholder`);
                box.element.innerHTML = '<div style="color: #6c757d; text-align: center; padding: 10px; font-size:12px;">No Image Available</div>';
                return;
            }
            
            const imageUrl = currentRow[box.fieldKey];
            console.log('Image URL from CSV:', imageUrl);
            if (!imageUrl) {
                console.log('No image URL found in CSV column');
                return;
            }
            
            // Use proxy to handle CORS
            const proxiedUrl = 'proxy_image.php?url=' + encodeURIComponent(imageUrl);
            console.log('Proxied URL for CSV image:', proxiedUrl);
            
            // Create image element
            const img = document.createElement('img');
            img.crossOrigin = 'anonymous'; // Add CORS attribute
            img.src = proxiedUrl;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            img.style.objectPosition = 'center';
            
            // Add error handling
            img.onerror = function() {
                console.error('Failed to load CSV image:', imageUrl);
                console.error('Error details:', this.src);
                box.element.innerHTML = '<div style="color: red; text-align: center; padding: 10px; font-size: 12px;">Failed to load CSV image<br>' + imageUrl + '</div>';
            };
            
            img.onload = function() {
                console.log('CSV image loaded successfully:', imageUrl);
            };
            
            // Clear existing content and add image
            box.element.innerHTML = '';
            box.element.appendChild(img);
            
            // Update box properties
            box.imageUrl = imageUrl;
        }

        function updateTextBoxContentSafely(element, text) {
            if (!element) return;
            
            // Store resize handles
            const resizeHandles = Array.from(element.querySelectorAll('.resize-handle'));
            
            // Update text content
            element.textContent = text;
            
            // Restore resize handles
            resizeHandles.forEach(handle => {
                element.appendChild(handle);
            });
        }

        function autoResizeTextBox(box) {
            if (!box || !box.element) return;
            
            const element = box.element;
            const text = element.textContent;
            
            if (!text) return;
            
            // Create a temporary element to measure text dimensions
            const tempElement = document.createElement('div');
            tempElement.style.cssText = `
                position: absolute;
                visibility: hidden;
                white-space: nowrap;
                font-family: ${element.style.fontFamily || 'Arial, sans-serif'};
                font-size: ${element.style.fontSize || '16px'};
                font-weight: ${element.style.fontWeight || 'normal'};
                font-style: ${element.style.fontStyle || 'normal'};
                padding: ${element.style.padding || '5px'};
                box-sizing: border-box;
            `;
            tempElement.textContent = text;
            
            document.body.appendChild(tempElement);
            
            // Get the measured dimensions
            const textWidth = tempElement.offsetWidth;
            const textHeight = tempElement.offsetHeight;
            
            // Remove the temporary element
            document.body.removeChild(tempElement);
            
            // Calculate new box dimensions with some padding
            const padding = 10;
            const newWidth = Math.max(20, textWidth + padding * 2);
            const newHeight = Math.max(10, textHeight + padding * 2);
            
            // Update the box dimensions
            element.style.width = newWidth + 'px';
            element.style.height = newHeight + 'px';
            
            // Update the box data
            box.width = newWidth;
            box.height = newHeight;
            
            // Update the position inputs in the editor
            const widthInput = document.getElementById('boxWidth');
            const heightInput = document.getElementById('boxHeight');
            if (widthInput) widthInput.value = newWidth;
            if (heightInput) heightInput.value = newHeight;
        }

        // Preview Mode functionality
        let isPreviewMode = false;

        function togglePreviewMode() {
            isPreviewMode = !isPreviewMode;
            const previewBtn = document.getElementById('previewModeBtn');
            const mainContainer = document.querySelector('.main-container');
            
            if (isPreviewMode) {
                // Enter Preview Mode - Clean view
                previewBtn.textContent = 'Edit Mode';
                previewBtn.className = 'btn btn-outline-primary';
                
                // Add preview mode styling to main container
                if (mainContainer) {
                    mainContainer.classList.add('preview-mode');
                }
                
                // Hide all transform controls
                hideAllTransformControls();
                
                // Clear all highlighting and borders
                clearAllHighlighting();
                
                // Hide all box borders/outlines for clean preview
                if (sessionState && sessionState.boxes) {
                    sessionState.boxes.forEach(box => {
                        if (box.element) {
                            // Remove all border styles and selection indicators
                            box.element.style.border = 'none';
                            box.element.style.outline = 'none';
                            box.element.style.boxShadow = 'none';
                            box.element.style.backgroundColor = '';
                            
                            // Remove selection classes
                            box.element.classList.remove('selected', 'multi-selected');
                            
                            // Hide any drag identifiers
                            const identifier = box.element.querySelector('.drag-identifier');
                            if (identifier) {
                                identifier.style.display = 'none';
                            }
                        }
                    });
                }
                
                // Hide record info display in preview mode
                const recordInfoDisplay = document.getElementById('recordInfoDisplay');
                if (recordInfoDisplay) {
                    recordInfoDisplay.style.display = 'none';
                }
                
                console.log('Preview mode activated - Clean PDF view');
                
            } else {
                // Exit Preview Mode - Return to editing
                previewBtn.textContent = 'Preview Mode';
                previewBtn.className = 'btn btn-outline-primary';
                
                // Remove preview mode styling
                if (mainContainer) {
                    mainContainer.classList.remove('preview-mode');
                }
                
                // Show all transform controls
                showAllTransformControls();
                
                // Show record info if a box is selected
                if (sessionState && sessionState.selectedBox) {
                    const recordInfoDisplay = document.getElementById('recordInfoDisplay');
                    if (recordInfoDisplay) {
                        recordInfoDisplay.style.display = 'block';
                    }
                }
                
                console.log('Edit mode restored - All controls visible');
            }
        }

        // Function to show all transform controls
        function showAllTransformControls() {
            const allHandles = document.querySelectorAll('.transform-control, .resize-handle');
            allHandles.forEach(handle => {
                // Reset any interfering transforms
                handle.style.transform = handle.style.transform.replace(/scale\([^)]*\)/g, '');
                
                // Force visibility with multiple approaches
                handle.style.opacity = '1';
                handle.style.visibility = 'visible';
                handle.style.display = 'block';
                handle.style.zIndex = '9999';
                
                // Use !important to override any conflicting styles
                handle.style.setProperty('opacity', '1', 'important');
                handle.style.setProperty('visibility', 'visible', 'important');
                handle.style.setProperty('display', 'block', 'important');
                handle.style.setProperty('z-index', '9999', 'important');
                
                // Ensure the handle is positioned correctly
                handle.style.pointerEvents = 'auto';
            });
            console.log('All transform controls shown - found', allHandles.length, 'handles');
        }

        // Function to hide all transform controls
        function hideAllTransformControls() {
            const allHandles = document.querySelectorAll('.transform-control, .resize-handle');
            allHandles.forEach(handle => {
                handle.style.opacity = '0';
                handle.style.visibility = 'hidden';
                handle.style.display = 'none';
            });
            console.log('All transform controls hidden');
        }

        // Function to clear all highlighting and borders
        function clearAllHighlighting() {
            const allBoxes = document.querySelectorAll('.draggable-text-box, .draggable-image-box');
            allBoxes.forEach(box => {
                box.style.border = 'none';
                box.style.outline = 'none';
                box.style.boxShadow = 'none';
                box.style.backgroundColor = '';
                box.classList.remove('selected', 'multi-selected');
            });
        }

        // Keyboard shortcut for preview mode (P key)
        document.addEventListener('keydown', function(event) {
            if (event.key === 'p' || event.key === 'P') {
                // Only trigger if not typing in an input field
                if (!['INPUT', 'TEXTAREA', 'SELECT'].includes(event.target.tagName)) {
                    event.preventDefault();
                    togglePreviewMode();
                }
            }
        });
    </script>
</body>
</html>
